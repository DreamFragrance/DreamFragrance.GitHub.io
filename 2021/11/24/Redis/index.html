<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis一、什么是 Redis？1.1、简介REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。 Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2021/11/24/Redis/index.html">
<meta property="og:site_name" content="紫梦沁香">
<meta property="og:description" content="Redis一、什么是 Redis？1.1、简介REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。 Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/24/oCz0ld.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/24/oPiTB9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/24/oPF3CV.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/24/oP3oRg.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/24/oPd3in.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/26/oEptuF.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/26/oEp041.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/26/oEpXUs.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/26/oZyOTs.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/26/oZ6F0J.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oZc5M8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oZgYy8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oZRigx.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oZReVe.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oZRHde.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oeNpJe.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oeNCzd.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oeaKrn.jpg">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oeysv8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oejcsU.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/27/oeXVBQ.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ouNngg.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ouNUv4.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ouNIat.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/oucAVU.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ougD61.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ouvfZ8.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/28/ouxz0f.png">
<meta property="article:published_time" content="2021-11-24T03:24:49.000Z">
<meta property="article:modified_time" content="2021-11-28T13:52:37.749Z">
<meta property="article:author" content="紫梦沁香">
<meta property="article:tag" content="NoSQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/11/24/oCz0ld.png">

<link rel="canonical" href="http://example.com/2021/11/24/Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | 紫梦沁香</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc20780b9c032635241d71c52b76953";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script type="text/javascript" src="/js/game/modernizr.custom.js"></script>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">紫梦沁香</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-game">

    <a href="/game/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/24/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/images/head-icon.jpg">
      <meta itemprop="name" content="紫梦沁香">
      <meta itemprop="description" content="如果说我看得比别人更远些，那是因为我站在巨人的肩膀上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="紫梦沁香">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-24 11:24:49" itemprop="dateCreated datePublished" datetime="2021-11-24T11:24:49+08:00">2021-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-28 21:52:37" itemprop="dateModified" datetime="2021-11-28T21:52:37+08:00">2021-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase-System/" itemprop="url" rel="index"><span itemprop="name">DataBase System</span></a>
                </span>
            </span>

          
            <span id="/2021/11/24/Redis/" class="post-meta-item leancloud_visitors" data-flag-title="Redis" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/24/Redis/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/24/Redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、什么是-Redis？"><a href="#一、什么是-Redis？" class="headerlink" title="一、什么是 Redis？"></a>一、什么是 Redis？</h2><h4 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h4><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p>
<p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p>
<p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oCz0ld.png" alt=""></p>
<h4 id="1-2、特点"><a href="#1-2、特点" class="headerlink" title="1.2、特点"></a>1.2、特点</h4><p>Redis 是完全开源的，遵守 BSD 协议（可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布），是一个高性能的 key-value 数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即 master-slave 模式的数据备份。</li>
</ul>
<span id="more"></span>
<h4 id="1-3、优势"><a href="#1-3、优势" class="headerlink" title="1.3、优势"></a>1.3、优势</h4><ul>
<li>性能极高 – Redis 能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h4 id="1-4、与其它-key-value-存储有什么不同？"><a href="#1-4、与其它-key-value-存储有什么不同？" class="headerlink" title="1.4、与其它 key-value 存储有什么不同？"></a>1.4、与其它 key-value 存储有什么不同？</h4><ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ul>
<h2 id="二、Redis-安装"><a href="#二、Redis-安装" class="headerlink" title="二、Redis 安装"></a>二、Redis 安装</h2><h4 id="2-1、安装"><a href="#2-1、安装" class="headerlink" title="2.1、安装"></a>2.1、安装</h4><p>先下载 Redis 的压缩包，<a target="_blank" rel="noopener" href="https://download.redis.io/releases/redis-6.2.6.tar.gz">Redis 6.2.6 is the latest stable version.</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz -C /usr <span class="comment"># 解压文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/redis-6.2.6 <span class="comment"># 进入该目录</span></span><br><span class="line">make <span class="comment"># 编译</span></span><br></pre></td></tr></tbody></table></figure>
<p>执行完 <strong>make</strong> 命令后，redis-6.2.6 的 <strong>src</strong> 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli：</p>
<p>下面启动 redis 服务：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server</span><br></pre></td></tr></tbody></table></figure>
<p>注意这种方式启动 redis 使用的是默认配置。也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动（源文件就当备份了，不要乱改）。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server MyRedis.conf</span><br></pre></td></tr></tbody></table></figure>
<p>默认配置文件是前台执行，需要手动配置成后台执行。</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oPiTB9.png" alt=""></p>
<p>之后启动就是在后台启动了</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oPF3CV.png" alt="image"></p>
<p>来尝试连接一下 Redis 数据库</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ./redis-cli -p 6379</span></span><br><span class="line"><span class="comment"># 连接成功！</span></span><br><span class="line">127.0.0.1:6379&gt;   </span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2、redis-benchmark-测试性能"><a href="#2-2、redis-benchmark-测试性能" class="headerlink" title="2.2、redis-benchmark 测试性能"></a>2.2、redis-benchmark 测试性能</h4><p>benchmark 可选参数如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>-h</strong></td>
<td style="text-align:left">指定服务器主机名</td>
<td style="text-align:left">127.0.0.1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>-p</strong></td>
<td style="text-align:left">指定服务器端口</td>
<td style="text-align:left">6379</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>-s</strong></td>
<td style="text-align:left">指定服务器 socket</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>-c</strong></td>
<td style="text-align:left">指定并发连接数</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>-n</strong></td>
<td style="text-align:left">指定请求数</td>
<td style="text-align:left">10000</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>-d</strong></td>
<td style="text-align:left">以字节的形式指定 SET/GET 值的数据大小</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>-k</strong></td>
<td style="text-align:left">1=keep alive 0=reconnect</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>-r</strong></td>
<td style="text-align:left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>-P</strong></td>
<td style="text-align:left">通过管道传输 <numreq> 请求</numreq></td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>-q</strong></td>
<td style="text-align:left">强制退出 redis。仅显示 query/sec 值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>—csv</strong></td>
<td style="text-align:left">以 CSV 格式输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong><em>-l\</em>（L 的小写字母）</strong></td>
<td style="text-align:left">生成循环，永久执行测试</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>-t</strong></td>
<td style="text-align:left">仅运行以逗号分隔的测试命令列表。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong><em>-I\</em>（i 的大写字母）</strong></td>
<td style="text-align:left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ./redis-benchmark -h 127.0.0.1 -p 6379 -n 100000 -c 100 -q</span></span><br><span class="line">PING_INLINE: 70521.86 requests per second, p50=0.999 msec                   </span><br><span class="line">PING_MBULK: 72150.07 requests per second, p50=0.967 msec                   </span><br><span class="line">SET: 62972.29 requests per second, p50=1.103 msec                   </span><br><span class="line">GET: 71839.09 requests per second, p50=0.975 msec                   </span><br><span class="line">INCR: 67340.07 requests per second, p50=1.039 msec                   </span><br><span class="line">LPUSH: 66401.06 requests per second, p50=1.071 msec                   </span><br><span class="line">RPUSH: 64061.50 requests per second, p50=1.103 msec                   </span><br><span class="line">LPOP: 62539.09 requests per second, p50=1.135 msec                   </span><br><span class="line">RPOP: 68634.18 requests per second, p50=1.031 msec                   </span><br><span class="line">SADD: 72098.05 requests per second, p50=0.975 msec                   </span><br><span class="line">HSET: 68259.38 requests per second, p50=1.031 msec                   </span><br><span class="line">SPOP: 71428.57 requests per second, p50=0.983 msec                   </span><br><span class="line">ZADD: 64850.84 requests per second, p50=1.087 msec                   </span><br><span class="line">ZPOPMIN: 71994.23 requests per second, p50=0.975 msec                   </span><br><span class="line">LPUSH (needed to benchmark LRANGE): 67476.38 requests per second, p50=1.055 msec                   </span><br><span class="line">LRANGE_100 (first 100 elements): 35893.75 requests per second, p50=1.967 msec                   </span><br><span class="line">LRANGE_300 (first 300 elements): 15257.86 requests per second, p50=4.439 msec                   </span><br><span class="line">LRANGE_500 (first 500 elements): 9705.91 requests per second, p50=6.943 msec                   </span><br><span class="line">LRANGE_600 (first 600 elements): 8294.62 requests per second, p50=8.167 msec                  </span><br><span class="line">MSET (10 keys): 59488.40 requests per second, p50=1.247 msec         </span><br></pre></td></tr></tbody></table></figure>
<h2 id="三、Redis-基本知识"><a href="#三、Redis-基本知识" class="headerlink" title="三、Redis 基本知识"></a>三、Redis 基本知识</h2><h4 id="3-1、数据库相关"><a href="#3-1、数据库相关" class="headerlink" title="3.1、数据库相关"></a>3.1、数据库相关</h4><p>Redis 默认有16个数据库，默认使用的是0号数据库。</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oP3oRg.png" alt=""></p>
<p><br></p>
<div class="note success">
            <p>select index 切换数据库</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 1	<span class="comment"># 切换1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; select 0 <span class="comment"># 切换为默认数据库</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>dbsize 查看当前数据库大小</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize		<span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>set 添加键值对，get 获取键值对</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name yqx	<span class="comment"># 添加键值对{name：yqx}</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; get name		<span class="comment"># 获取键为name的值</span></span><br><span class="line"><span class="string">"yqx"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>keys * 获取所有的键</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *		<span class="comment"># 获取所有的键</span></span><br><span class="line">1) <span class="string">"name"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>flushdb 清空当前数据库</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushdb		<span class="comment"># 清空数据库，flushall清空所有数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *		<span class="comment"># 再次查看数据库内容</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>flushall 清空所有数据库</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">127.0.0.1:6379[3]&gt; select 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; flushall	<span class="comment"># 清空所有数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; select 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-2、Redis-Key"><a href="#3-2、Redis-Key" class="headerlink" title="3.2、Redis-Key"></a>3.2、Redis-Key</h4><p>命令很多，这里只介绍常用的命令，如果之后碰到新的命令可以到官网查看。</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oPd3in.png" alt=""></p>
<div class="note success">
            <p>del key 删除 key</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379&gt; del name	<span class="comment"># 删除key为name的键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>exists key 是否存在该键值对，存在则返回1，不存在则返回0</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists name	<span class="comment"># 是否存在键为name的键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>expire key time 为该键值对设置有效时间，单位为秒</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire name 5 <span class="comment"># 设置name的有效时间为5秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name	  <span class="comment"># 查看name的有效时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name	  <span class="comment"># 有效时间过了，则无法获取name</span></span><br><span class="line">(nil)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>type key 查看键值对的存储类型</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> hello	<span class="comment"># 查看hello的类型</span></span><br><span class="line">string</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>rename key newkey 重命名键</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rename hello hi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"hi"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>persist key 移除该键值对的过期时间，改为持久保存</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire name 30	<span class="comment"># 设置过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; persist name	<span class="comment"># 移除过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"yqx"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="四、五大基本类型"><a href="#四、五大基本类型" class="headerlink" title="四、五大基本类型"></a>四、五大基本类型</h2><h4 id="4-1、字符串（String）"><a href="#4-1、字符串（String）" class="headerlink" title="4.1、字符串（String）"></a>4.1、字符串（String）</h4><div class="note success">
            <p>getrange key start end 获取子串</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">"hello,my name is LiHua!"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">"hello,my name is LiHua!"</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 2 5				<span class="comment"># 获取子串，左闭右闭</span></span><br><span class="line"><span class="string">"llo,"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>getset key value 先获取值，再设置值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset key1 <span class="string">"it's new string"</span>	<span class="comment"># 先获取，再设置值</span></span><br><span class="line"><span class="string">"hello,my name is LiHua!"</span>						<span class="comment"># 注：有特殊字符必须加""</span></span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">"it's new string"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>strlen 获取字符串长度</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; strlen key1						<span class="comment"># 获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 17									<span class="comment"># 此长度不包含双引号</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>mset key1 value1 key2 value2… 批量设置键值对</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3			<span class="comment"># 批量设置键值对</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>mget key1 key2…</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3					<span class="comment"># 批量获取键值对</span></span><br><span class="line">1) <span class="string">"v1"</span></span><br><span class="line">2) <span class="string">"v2"</span></span><br><span class="line">3) <span class="string">"v3"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>setex key time value 如果存在该键值对，则修改值；不存在则添加该键值对。最后设置有效时间</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex key1 10 value1			<span class="comment"># set expire</span></span><br><span class="line">OK												<span class="comment"># 如果没有该键值对则会创建并添加有效时间</span></span><br><span class="line">127.0.0.1:6379&gt; get key1						</span><br><span class="line"><span class="string">"value1"</span></span><br><span class="line">127.0.0.1:6379&gt; ttl key1				</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; setex key1 10 value2			<span class="comment"># 如果有该键值对则会修改并添加有效时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key1				</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; get key1						</span><br><span class="line"><span class="string">"value2"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>setnx key value 如果不存在该键值对，则添加；存在则不操作，不会修改值！</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key2 value2				<span class="comment"># set if not exists</span></span><br><span class="line">(<span class="built_in">integer</span>) 1										<span class="comment"># 如果没有该键值对则成功创建</span></span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value3				<span class="comment"># 有则创建失败，不会修改值！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key2						</span><br><span class="line"><span class="string">"value2"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>incr key 自增加1，必须是整数或是可以转换为整数的字符串！</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> num 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get num</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1		<span class="comment"># 给字符串自增，结果报错！（非整数都一样）</span></span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>incrby key increment 设置增量</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY num 10</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get num</span><br><span class="line"><span class="string">"13"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>decr key 自减1，必须是整数！</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; get num</span><br><span class="line"><span class="string">"11"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>decrby key increment 设置减量</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decrby num 5</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get num</span><br><span class="line"><span class="string">"6"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>append key value 追加值到该键值对中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append name deflory		<span class="comment"># 追加deflory到key为name的键值对中</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"yqxdeflory"</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="4-2、哈希（Hash）"><a href="#4-2、哈希（Hash）" class="headerlink" title="4.2、哈希（Hash）"></a>4.2、哈希（Hash）</h4><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 $2^{32}$ - 1 键值对（40多亿）。</p>
<p><br></p>
<p><strong>hash 大部分的命令都是以 h 开头，表示这是 hash 的命令</strong></p>
<div class="note success">
            <p>hset hash k1 v1 k2 v2 同时设置一个或多个键值对到 hash中（hmset 和它的功能一模一样）</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user:1:{</span></span><br><span class="line"><span class="comment">#	name: "yqx",</span></span><br><span class="line"><span class="comment">#	age : 16</span></span><br><span class="line"><span class="comment">#}</span></span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name yqx age 16</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hget hash key 获取该 hash 中指定键的值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name	<span class="comment"># 获取name值</span></span><br><span class="line"><span class="string">"yqx"</span></span><br><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line"><span class="string">"16"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hgetall key 获取该 hash 中所有的键值对</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"yqx"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"16"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hexists hash key 返回该 hash 中是否存在以 key 为键的键值对</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name	<span class="comment"># 是否存在name键</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists user:1 job</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hkeys hash 获取该 hash 中的所有键</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1	<span class="comment"># 获取所有键</span></span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hvals hash 获取该 hash 中的所有值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1	<span class="comment"># 获取所有值</span></span><br><span class="line">1) <span class="string">"yqx"</span></span><br><span class="line">2) <span class="string">"16"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hincrby hash key increment 为 hash 中键为 key 的值（整型）加一个增量 increment</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 10	<span class="comment"># 年龄+10</span></span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line"><span class="string">"26"</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby user:1 name 10</span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hincrby hash key increment 为 hash 中键为 key 的值加一个增量 increment</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"yqx"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"26"</span></span><br><span class="line">5) <span class="string">"weight"</span></span><br><span class="line">6) <span class="string">"60.2"</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby user:1 weight 10		<span class="comment"># float类型无法使用int的自增方法</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 weight 10	<span class="comment"># 体重+10</span></span><br><span class="line"><span class="string">"70.2"</span></span><br><span class="line">127.0.0.1:6379&gt; hget user:1 weight</span><br><span class="line"><span class="string">"70.2"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hlen hash 获取该 hash 中的键值对数量</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br><span class="line">3) <span class="string">"weight"</span></span><br><span class="line">127.0.0.1:6379&gt; hlen user:1	<span class="comment"># 获取键值对数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hmget hash k1 k2… 获取所有给定字段的值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget user:1 name weight</span><br><span class="line">1) <span class="string">"yqx"</span></span><br><span class="line">2) <span class="string">"70.2"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hsetnx hash key value 只有在字段 key 不存在时，才会设置值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx user:1 name deflory	<span class="comment"># set if not exist</span></span><br><span class="line">(<span class="built_in">integer</span>) 0									<span class="comment"># 字段存在，设值失败</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx user:1 height 175</span><br><span class="line">(<span class="built_in">integer</span>) 1									<span class="comment"># 字段不存在，设值成功</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"yqx"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"26"</span></span><br><span class="line">5) <span class="string">"weight"</span></span><br><span class="line">6) <span class="string">"70.2"</span></span><br><span class="line">7) <span class="string">"height"</span></span><br><span class="line">8) <span class="string">"175"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>hscan hash cursor [MATCH pattern] [COUNT count] 迭代 hash 的键值对并进行匹配（count 默认为10）</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan user:1 0 match <span class="string">"*gh*"</span>	<span class="comment"># 从下标0开始匹配键中包含gh的项</span></span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"weight"</span></span><br><span class="line">   2) <span class="string">"70.2"</span></span><br><span class="line">   3) <span class="string">"height"</span></span><br><span class="line">   4) <span class="string">"175"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<h4 id="4-3、列表（List）"><a href="#4-3、列表（List）" class="headerlink" title="4.3、列表（List）"></a>4.3、列表（List）</h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 $2^{32}$ - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p><br></p>
<p><strong>list 大部分的命令都是以 L 开头，表示这是 list 的命令</strong></p>
<div class="note success">
            <p>lpush list value 将数组从左边插入到 list 中，没有该列表，则会先创建再插入</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list redis		 <span class="comment"># 插入redis</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list mongodb mysql <span class="comment"># 可以同时插入多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lpushx list value 将数组从左边插入到一个<code>存在</code>的 list 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpushx list2 yqx	<span class="comment"># pushx 到一个不存在的列表中</span></span><br><span class="line">(<span class="built_in">integer</span>) 0							<span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list2 0</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpushx list oracle	<span class="comment"># 只能 pushx 到存在的列表中</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"oracle"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lrange list start end 查看 list 指定范围的数据（左闭右闭）</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment"># push和栈一样，最后放进来的在最上面</span></span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange list 1 2  <span class="comment"># 查看下标区间为[1, 2]的数据</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lindex list index 获取指定下标的元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">"mysql"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>linsert list before|after pivot value 在列表元素的前面或后面插入元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert list before redis oracle <span class="comment"># 在list列表中redis前面插入oracle，如果有多个redis，默认插入在第一个redis前</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"oracle"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>llen list 获取列表长度</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list	<span class="comment"># 查看list的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lpop list 弹出列表第一个元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"oracle"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lpop list	<span class="comment"># list第一个元素是mysql</span></span><br><span class="line"><span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lrem list count value 移出列表元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"oracle"</span></span><br><span class="line">4) <span class="string">"sqlserver"</span></span><br><span class="line">5) <span class="string">"oracle"</span></span><br><span class="line">6) <span class="string">"mysql"</span></span><br><span class="line">7) <span class="string">"mongodb"</span></span><br><span class="line">8) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 oracle	<span class="comment"># count&gt;0，从前往后找</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"oracle"</span></span><br><span class="line">5) <span class="string">"mysql"</span></span><br><span class="line">6) <span class="string">"mongodb"</span></span><br><span class="line">7) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list -1 mysql  <span class="comment"># count&lt;0，从前往后找</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"oracle"</span></span><br><span class="line">5) <span class="string">"mongodb"</span></span><br><span class="line">6) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>lset list index value 通过索引设置列表元素的值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lset list 0 mybatis	<span class="comment"># 将第一个元素改为mybatis</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mybatis"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"oracle"</span></span><br><span class="line">5) <span class="string">"mongodb"</span></span><br><span class="line">6) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>ltrim list start stop 只保留 list 在区间[start, stop]上的元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"mybatis"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"oracle"</span></span><br><span class="line">5) <span class="string">"mongodb"</span></span><br><span class="line">6) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim list 2 5	<span class="comment"># 截断list[2, 5]</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>rpush list value 在列表末尾插入元素，同 lpush</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list mysql hibernate</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">5) <span class="string">"mysql"</span></span><br><span class="line">6) <span class="string">"hibernate"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>rpushx list value 在已存在列表末尾插入元素，同 rpushx</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpushx name deflory</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; rpushx list2 hello world</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">"test"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"world"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>rpop list 弹出列表最后一个元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">5) <span class="string">"mysql"</span></span><br><span class="line">6) <span class="string">"hibernate"</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list	<span class="comment"># 弹出list最后一个元素</span></span><br><span class="line"><span class="string">"hibernate"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">5) <span class="string">"mysql"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>rpoplpush source destination 将 source 中最后一个元素插入到 destination 最前面</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原列表</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">5) <span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">"test"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list list2</span><br><span class="line"><span class="string">"mysql"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现列表</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">"sqlserver"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"test"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="5px">小结：</font></strong></p>
<ul>
<li><p>list 列表实际上是一个链表</p>
</li>
<li><p>如果移除了链表中的所有值，那么该链表不存在</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list v1 v2	<span class="comment"># 创建测试列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 v1		<span class="comment"># 移除所有元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 v2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1	<span class="comment"># 查看数组内容</span></span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpushx list v3		<span class="comment"># 无法给空数组lpushx元素！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1	<span class="comment"># 还是空数组!</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在两遍插入或修改值时，效率最高！反之，操作中间元素时，效率较低！</p>
</li>
<li><p>如果只使用 lpush，rpop，即消息队列；只使用 lpush、lpop，即栈。</p>
</li>
</ul>
<h4 id="4-4、集合（Set）"><a href="#4-4、集合（Set）" class="headerlink" title="4.4、集合（Set）"></a>4.4、集合（Set）</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>集合对象的编码可以是 intset 或者 hashtable。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 $2^{32} - 1$ (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><br></p>
<p><strong>set 大部分的命令都是以 s 开头，表示这是 set 的命令</strong></p>
<div class="note success">
            <p>sadd set value 添加 value 到 set 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> redis mongodb <span class="comment"># 可以同时添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> mysql</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>smembers set 查看该集合中的元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> mysql</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">set</span> mysql	<span class="comment"># 添加两个mysql</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span>	<span class="comment"># 最后集合中只有一个mysql</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"mysql"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>scard set 查看该集合数量</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard <span class="built_in">set</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sdiff set1 set2 求差集（set1 - set2）</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff <span class="built_in">set</span> set2	<span class="comment"># 在set中而不在set2中的就是redis和mongodb</span></span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sdiffstore destination set1 set2 将 set1 和 set2 的差集存储在 destination 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sdiffstore result <span class="built_in">set</span> set2	<span class="comment"># 将结果存储在result中</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers result</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sinter set1 set2 求 set1 和 set2 的交集</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinter <span class="built_in">set</span> set2</span><br><span class="line">1) <span class="string">"mysql"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sinnerstore destination set1 set2 将 set1 和 set2 的交集存储在 destination 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore result <span class="built_in">set</span> set2	<span class="comment"># 会将原先result中的内容覆盖</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers result</span><br><span class="line">1) <span class="string">"mysql"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sunion set1 set2 求 set1 和 set2 的并集</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"sqlserver"</span></span><br><span class="line">3) <span class="string">"oracle"</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; sunion <span class="built_in">set</span> set2</span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"python"</span></span><br><span class="line">5) <span class="string">"java"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>sunionstore destination set1 set2 将 set1 和 set2 的并集存储在 destination 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sunionstore result <span class="built_in">set</span> set2</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; smembers result</span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"python"</span></span><br><span class="line">5) <span class="string">"java"</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note success">
            <p>sismember set member 判断 member 是否存在于 set 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers result</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; sismember result mysql	<span class="comment"># mysql存在于result中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember result mysql1 <span class="comment"># mysql1不存在与result中</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>smove source destination member 将 member 从 source 中转移到destination 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; smove <span class="built_in">set</span> set2 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"java"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>spop set 随机弹出 set 中的某个元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; spop set2</span><br><span class="line"><span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; spop set2</span><br><span class="line"><span class="string">"mysql"</span></span><br><span class="line">127.0.0.1:6379&gt; spop set2</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; spop set2</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; spop set2</span><br><span class="line">(nil)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>srandmember set [count] 随即返回集合中的元素，默认count=1（不移除！）</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"oracle"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br><span class="line">4) <span class="string">"mysql"</span></span><br><span class="line">5) <span class="string">"mongodb"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember <span class="built_in">set</span></span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember <span class="built_in">set</span></span><br><span class="line"><span class="string">"oracle"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember <span class="built_in">set</span> 3</span><br><span class="line">1) <span class="string">"mysql"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"sqlserver"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>srem set value1 value2… 移除集合中的元素</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"mysql"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br><span class="line">4) <span class="string">"sqlserver"</span></span><br><span class="line">5) <span class="string">"oracle"</span></span><br><span class="line">127.0.0.1:6379&gt; srem <span class="built_in">set</span> redis mysql</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">set</span></span><br><span class="line">1) <span class="string">"mongodb"</span></span><br><span class="line">2) <span class="string">"sqlserver"</span></span><br><span class="line">3) <span class="string">"oracle"</span></span><br></pre></td></tr></tbody></table></figure>
<p>可用于微博，共同关注，共同爱好，推荐好友等……</p>
<h4 id="4-5、有序集合（sorted-set）"><a href="#4-5、有序集合（sorted-set）" class="headerlink" title="4.5、有序集合（sorted set）"></a>4.5、有序集合（sorted set）</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 $2^{32} - 1$ (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><br></p>
<div class="note success">
            <p>zadd zset score1 member1 score2 member2…. 向有序集合添加一个或多个成员，或者更新成员分数</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd salary 500 yqx 1000 sk 3000 deflory</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zcard zset 获取有序集合的元素个数</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrange zset min max byscore 根据分数从小到大返回数据</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary -inf +inf byscore</span><br><span class="line">1) <span class="string">"yqx"</span></span><br><span class="line">2) <span class="string">"sk"</span></span><br><span class="line">3) <span class="string">"deflory"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zcount zset min max 查找指定范围内的元素个数</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount salary 10 1000</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zscore zset member 获取指定某个成员的分数</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore salary yqx</span><br><span class="line"><span class="string">"500"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zincrby zset increment member 为指定成员添加增量</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zincrby salary 20 nojob</span><br><span class="line"><span class="string">"20"</span></span><br><span class="line">127.0.0.1:6379&gt; zscore salary nojob</span><br><span class="line"><span class="string">"20"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrank zset member 获取指定成员的索引</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrank salary yqx</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrangebyscore zset -inf +inf [withscores] 根据分数从小到大返回数据，可以选择是否连同分数一起返回</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores</span><br><span class="line">1) <span class="string">"nojob"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br><span class="line">3) <span class="string">"yqx"</span></span><br><span class="line">4) <span class="string">"500"</span></span><br><span class="line">5) <span class="string">"sk"</span></span><br><span class="line">6) <span class="string">"1000"</span></span><br><span class="line">7) <span class="string">"deflory"</span></span><br><span class="line">8) <span class="string">"3000"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrevrange zset start end [withscores] 根据分数从大到小且索引在[start, end]中的数据，可以选择是否连同分数一起返回</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 10 withscores</span><br><span class="line">1) <span class="string">"deflory"</span></span><br><span class="line">2) <span class="string">"3000"</span></span><br><span class="line">3) <span class="string">"sk"</span></span><br><span class="line">4) <span class="string">"1000"</span></span><br><span class="line">5) <span class="string">"yqx"</span></span><br><span class="line">6) <span class="string">"500"</span></span><br><span class="line">7) <span class="string">"nojob"</span></span><br><span class="line">8) <span class="string">"20"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrevrangebyscore zset max min [withscores] 根据分数从大到小，范围在[min, max]返回数据，可以选择是否连同分数一起返回</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrangebyscore salary +inf -inf withscores</span><br><span class="line">1) <span class="string">"deflory"</span></span><br><span class="line">2) <span class="string">"3000"</span></span><br><span class="line">3) <span class="string">"sk"</span></span><br><span class="line">4) <span class="string">"1000"</span></span><br><span class="line">5) <span class="string">"yqx"</span></span><br><span class="line">6) <span class="string">"500"</span></span><br><span class="line">7) <span class="string">"nojob"</span></span><br><span class="line">8) <span class="string">"20"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>zrem zset member1 member2… 删除指定多个成员</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem salary nojob</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary -inf +inf byscore</span><br><span class="line">1) <span class="string">"yqx"</span></span><br><span class="line">2) <span class="string">"sk"</span></span><br><span class="line">3) <span class="string">"deflory"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="五、三种特殊数据类型"><a href="#五、三种特殊数据类型" class="headerlink" title="五、三种特殊数据类型"></a>五、三种特殊数据类型</h2><h4 id="5-1、Geo"><a href="#5-1、Geo" class="headerlink" title="5.1、Geo"></a>5.1、Geo</h4><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p>
<p>Redis GEO 操作方法有：</p>
<ul>
<li>geoadd：添加地理位置的坐标。</li>
<li>geopos：获取地理位置的坐标。</li>
<li>geodist：计算两个位置之间的距离。</li>
<li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li>
<li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li>
<li>geohash：返回一个或多个位置对象的 geohash 值。</li>
</ul>
<p><br></p>
<div class="note success">
            <p>geoadd geo longitude1 latitude1 member1… 将多个经纬度和位置名称的信息添加到 geo 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem salary nojob</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary -inf +inf byscore</span><br><span class="line">1) <span class="string">"yqx"</span></span><br><span class="line">2) <span class="string">"sk"</span></span><br><span class="line">3) <span class="string">"deflory"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>geopos geo member1 member2 获取多个成员的地理位置</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos geo Palermo	<span class="comment"># 获取Palermo的地理位置</span></span><br><span class="line">1) 1) <span class="string">"13.36099773645401001"</span>		<span class="comment"># 由于十转二数据精度丢失的问题</span></span><br><span class="line">   2) <span class="string">"38.1149987568412385"</span>			<span class="comment"># 这里一般直接与我们设置的值大致相等</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>geodist geo member1 member2 [m|km|ft|mi] 获取两个成员间的距离</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist geo Palermo Catania <span class="comment"># 计算Palermo与Catania的距离</span></span><br><span class="line"><span class="string">"166290.2746"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>geodius geo longitude latitude radius m|km [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] 获取 geo 在以给定经纬度为圆心，radius 为半径的圆中的成员集合</p>
          </div>
<ul>
<li>m ：米，默认单位。</li>
<li>km ：千米。</li>
<li>mi ：英里。</li>
<li>ft ：英尺。</li>
<li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li>
<li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
<li>COUNT 限定返回的记录数。</li>
<li>ASC: 查找结果根据距离从近到远排序。</li>
<li>DESC: 查找结果根据从远到近排序。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius geo 15 37 200 km</span><br><span class="line">1) <span class="string">"Palermo"</span></span><br><span class="line">2) <span class="string">"Catania"</span></span><br><span class="line">127.0.0.1:6379&gt; georadius geo 15 37 200 km withcoord	<span class="comment"># 返回经纬度</span></span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) 1) <span class="string">"13.36099773645401001"</span></span><br><span class="line">      2) <span class="string">"38.1149987568412385"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) 1) <span class="string">"15.08699923753738403"</span></span><br><span class="line">      2) <span class="string">"37.50199925694555247"</span></span><br><span class="line">127.0.0.1:6379&gt; georadius geo 15 37 200 km withdist		<span class="comment"># 返回到圆心距离</span></span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4286"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.3643"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>georadiusbymember 语法同上，但是以成员为圆心</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd geo 13.583333 37.316667 <span class="string">"Agrigento"</span> 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember geo Agrigento 100 km	<span class="comment"># 获取距离Agrigento距离100km范围内的成员</span></span><br><span class="line">1) <span class="string">"Agrigento"</span></span><br><span class="line">2) <span class="string">"Palermo"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>geohash member1 member2 获取多个成员的 geohash 值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash geo Palermo Catania</span><br><span class="line">1) <span class="string">"sqc8b49rny0"</span></span><br><span class="line">2) <span class="string">"sqdtr74hyu0"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<p><code>因为 geo 底层是使用 zset 实现的，因此我们可以使用 zset 的方法在 geo 上！！！</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange geo 0 -1	<span class="comment"># 使用zrange获取geo中所有的成员</span></span><br><span class="line">1) <span class="string">"Agrigento"</span></span><br><span class="line">2) <span class="string">"Palermo"</span></span><br><span class="line">3) <span class="string">"Catania"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<h4 id="5-2、HyperLogLog"><a href="#5-2、HyperLogLog" class="headerlink" title="5.2、HyperLogLog"></a>5.2、HyperLogLog</h4><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，<strong>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</strong></p>
<p><br></p>
<p><strong>那么什么是基数呢？</strong></p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p><br></p>
<div class="note success">
            <p>pfadd pf v1 v2 v3… 添加多个值到 HyperLogLog 中</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd pf1 a b c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd pf2 a b c x y z</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>pfcount pf1 [pf2…] 返回给定 HyperLogLog 的基数估算值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfcount pf1	<span class="comment"># pf1基数为7</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; pfcount pf2	<span class="comment"># pf2基数为6</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfcount pf1 pf2	<span class="comment"># pf1和pf2组合的HyperLogLog基数为10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>pfmerge destkey sourcekey [sourcekey…]</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfmerge pf1 pf2 <span class="comment"># 将pf1和pf2合并的结果赋给pf1</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount pf1		<span class="comment"># 合并后pf1的基数为10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; pfcount pf2		<span class="comment"># 合并后pf2没有改变，基数为6</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfcount pf1 pf2	<span class="comment"># 与用pfcount求基数结果一致</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<h4 id="5-3、Bitmaps"><a href="#5-3、Bitmaps" class="headerlink" title="5.3、Bitmaps"></a>5.3、Bitmaps</h4><p>Bitmaps 位图，是一种数据结构，通过操作二进制位来进行记录，只有0和1两个状态。</p>
<p>如果要统计一年的打卡情况，365天 = 365bit，约等于46B。</p>
<p><br></p>
<div class="note success">
            <p>setbit bitmap index value 设值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bitmap 0 2	<span class="comment"># 位图只有0和1两种状态</span></span><br><span class="line">(error) ERR bit is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 0 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 0 1	<span class="comment"># 重新将下标0的值设为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>bitcount bitmap 统计值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount bitmap</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>getbit 获取指定下标的值</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit bitmap 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit bitmap 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></tbody></table></figure>
<h2 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<p><br></p>
<h4 id="6-1、开启事务"><a href="#6-1、开启事务" class="headerlink" title="6.1、开启事务"></a>6.1、开启事务</h4><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi	<span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> age 16</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> weight 60</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>	<span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"yqx"</span></span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line"><span class="string">"16"</span></span><br><span class="line">127.0.0.1:6379&gt; get weight</span><br><span class="line"><span class="string">"60"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<p><strong>当事务中出现编译错误时，这其中所有的操作都不会被执行</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set123 age 16	<span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `set123`, with args beginning with: `age`, `16`, </span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> height 175</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get name	<span class="comment"># 没有获取到name的值</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get height</span><br><span class="line">(nil)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，<strong>中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</strong>。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> age 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr name	<span class="comment"># 此为语法错误，字符串无法进行自增运算</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK	<span class="comment"># 除了语法错误的命令，其他命令都正确执行了</span></span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">4) <span class="string">"yqx"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>discard 取消事务</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; zadd zset 10 score</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard	<span class="comment"># 取消事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-2、watch-监听"><a href="#6-2、watch-监听" class="headerlink" title="6.2、watch 监听"></a>6.2、watch 监听</h4><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候会进行判断，在此前是否有人修改过这个数据。</li>
</ul>
<div class="note success">
            <p>watch key1 key2… 监听一个或多个 key ，如果在事务执行之前，这个 key 被其它命令所改动，那么事务将被打断，由此实现乐观锁的效果。</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money	<span class="comment"># 监听money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi	<span class="comment"># 启动事务</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>
<p>在启动事务的同时，我们新连接一个 redis 客户端，修改 money 的值。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>
<p>此时再回到第一个客户端，完善事务。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby money 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby out 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>	<span class="comment"># 事务没有执行，被打断了</span></span><br><span class="line">(nil)</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<div class="note success">
            <p>与 watch 相对的，有一个命令叫做 unwatch，用于取消对所有 key 的监视</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; unwatch	<span class="comment"># 取消监听</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>
<h2 id="七、Jedis"><a href="#七、Jedis" class="headerlink" title="七、Jedis"></a>七、Jedis</h2><h4 id="7-1、配置"><a href="#7-1、配置" class="headerlink" title="7.1、配置"></a>7.1、配置</h4><p>如果想要在 Java 中连接 Redis，就需要使用 Jedis 这个 jar 包，以下是它的 Maven 依赖。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>当然，在连接之前还需要修改一下阿里云中 Redis 的配置文件，如下。</p>
<ol>
<li><p>注释 bind 127.0.0.1</p>
<p><img src="https://z3.ax1x.com/2021/11/26/oEptuF.png" alt=""></p>
</li>
<li><p>protect-mode 改为 no</p>
<p><img src="https://z3.ax1x.com/2021/11/26/oEp041.png" alt=""></p>
</li>
</ol>
<p>之后重启 Redis 即可。</p>
<ul>
<li><p>停止所有客户端</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli shutdown</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>启动 Redis</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ../MyRedis.conf</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>测试连接，成功输出 <code>PONG</code>!</p>
<p><img src="https://z3.ax1x.com/2021/11/26/oEpXUs.png" alt=""></p>
<h4 id="7-2、Jedis-使用"><a href="#7-2、Jedis-使用" class="headerlink" title="7.2、Jedis 使用"></a>7.2、Jedis 使用</h4><p>测试键</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KeyTest</span><span class="params">()</span> </span>{</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"47.102.124.75"</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">"清空数据:"</span> + jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">"判断某个键是否存在:"</span> + jedis.exists(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(<span class="string">"新增&lt;'username','deflory'&gt;的键值对:"</span> + jedis.set(<span class="string">"username"</span>, <span class="string">"deflory"</span>));</span><br><span class="line">        System.out.println(<span class="string">"新增&lt;'password','123456'&gt;的键值对:"</span> + jedis.set(<span class="string">"password"</span>, <span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"系统中所有的键:"</span> + jedis.keys(<span class="string">"*"</span>));</span><br><span class="line">        System.out.println(<span class="string">"删除键password:"</span> + jedis.del(<span class="string">"password"</span>));</span><br><span class="line">        System.out.println(<span class="string">"判断键password是否存在:"</span> + jedis.exists(<span class="string">"password"</span>));</span><br><span class="line">        System.out.println(<span class="string">"查看键username所存储值的类型:"</span> + jedis.type(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(<span class="string">"随即返回key空间中的一个:"</span> + jedis.randomKey());</span><br><span class="line">        System.out.println(<span class="string">"重命名username为name:"</span> + jedis.rename(<span class="string">"username"</span>, <span class="string">"name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"取出修改后的name:"</span> + jedis.get(<span class="string">"name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"切换至1号数据库:"</span> + jedis.select(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"查看当前数据库大小:"</span> + jedis.dbSize());</span><br><span class="line">        System.out.println(<span class="string">"切换回默认数据库:"</span> + jedis.select(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"删除当前选中数据库的所有key:"</span> + jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">"系统中所有的键:"</span> + jedis.keys(<span class="string">"*"</span>));</span><br><span class="line">        System.out.println(<span class="string">"删除所有数据库中的所有key:"</span> + jedis.flushAll());</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>测试 String</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void StringTest() throws InterruptedException {</span><br><span class="line">    Jedis jedis = new Jedis(<span class="string">"47.102.124.75"</span>, 6379);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">"============增加数据============"</span>);</span><br><span class="line">    System.out.println(jedis.set(<span class="string">"key1"</span>, <span class="string">"value1"</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">"key2"</span>, <span class="string">"value2"</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">"key3"</span>, <span class="string">"value3"</span>));</span><br><span class="line">    System.out.println(<span class="string">"删除键key2:"</span> + jedis.del(<span class="string">"key2"</span>));</span><br><span class="line">    System.out.println(<span class="string">"获取键key2:"</span> + jedis.get(<span class="string">"key2"</span>));</span><br><span class="line">    System.out.println(<span class="string">"修改键key1:"</span> + jedis.set(<span class="string">"key1"</span>, <span class="string">"NewValue1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"在key3的值后面追加值:"</span> + jedis.append(<span class="string">"key3"</span>, <span class="string">"End"</span>));</span><br><span class="line">    System.out.println(<span class="string">"获取key3的值:"</span> + jedis.get(<span class="string">"key3"</span>));</span><br><span class="line">    System.out.println(<span class="string">"增加多个键值对:"</span> + jedis.mset(<span class="string">"key01"</span>, <span class="string">"value01"</span>, <span class="string">"key02"</span>, <span class="string">"value02"</span>, <span class="string">"key03"</span>, <span class="string">"value03"</span>));</span><br><span class="line">    System.out.println(<span class="string">"获取多个键值对:"</span> + jedis.mget(<span class="string">"key01"</span>, <span class="string">"key02"</span>, <span class="string">"key03"</span>));</span><br><span class="line">    System.out.println(<span class="string">"删除多个键值对:"</span> + jedis.del(<span class="string">"key01"</span>, <span class="string">"key02"</span>));</span><br><span class="line">    System.out.println(<span class="string">"获取多个键值对:"</span> + jedis.mget(<span class="string">"key01"</span>, <span class="string">"key02"</span>, <span class="string">"key03"</span>));</span><br><span class="line"></span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">"============新增键值对防止覆盖原先值============"</span>);</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">"key1"</span>, <span class="string">"value1"</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">"key2"</span>, <span class="string">"value2"</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">"key2"</span>, <span class="string">"NewValue2"</span>));</span><br><span class="line">    System.out.println(jedis.mget(<span class="string">"key1"</span>, <span class="string">"key2"</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"============新增键值对并设置有效时间============"</span>);</span><br><span class="line">    System.out.println(jedis.setex(<span class="string">"key3"</span>, 2, <span class="string">"value3"</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">"key3"</span>));</span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">"key3"</span>));</span><br><span class="line">    Thread.sleep(4000);</span><br><span class="line">    System.out.println(<span class="string">"4秒后......"</span>);</span><br><span class="line">    System.out.println(jedis.get(<span class="string">"key3"</span>));</span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">"key3"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试 Set</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetTest</span><span class="params">()</span></span>{</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"47.102.124.75"</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">"添加数据到集合1:"</span> + jedis.sadd(<span class="string">"set1"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>));</span><br><span class="line">    System.out.println(<span class="string">"添加数据到集合2:"</span> + jedis.sadd(<span class="string">"set2"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看集合1元素数量:"</span> + jedis.scard(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看集合1元素:"</span> + jedis.smembers(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"集合1与集合2差集:"</span> + jedis.sdiff(<span class="string">"set1"</span>, <span class="string">"set2"</span>));</span><br><span class="line">    System.out.println(<span class="string">"集合1与集合2并集:"</span> + jedis.sunion(<span class="string">"set1"</span>, <span class="string">"set2"</span>));</span><br><span class="line">    System.out.println(<span class="string">"集合1与集合2交集:"</span> + jedis.sinter(<span class="string">"set1"</span>, <span class="string">"set2"</span>));</span><br><span class="line">    System.out.println(<span class="string">"随机移除集合1的一个元素:"</span> + jedis.spop(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看集合1元素:"</span> + jedis.smembers(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"随机返回集合1的三个元素"</span> + jedis.srandmember(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看g是否存储在集合2中:"</span> + jedis.sismember(<span class="string">"set2"</span>, <span class="string">"g"</span>));</span><br><span class="line">    System.out.println(<span class="string">"将集合2的g移动到集合1中:"</span> + jedis.smove(<span class="string">"set2"</span>, <span class="string">"set1"</span>, <span class="string">"g"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看集合1的元素:"</span> + jedis.smembers(<span class="string">"set1"</span>));</span><br><span class="line">    System.out.println(<span class="string">"移除集合1的g:"</span> + jedis.srem(<span class="string">"set1"</span>, <span class="string">"g"</span>));</span><br><span class="line">    System.out.println(<span class="string">"查看集合1的元素:"</span> + jedis.smembers(<span class="string">"set1"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>太多了，后面的就不写了，和 Redis 的使用差不多！</p>
<p>事务</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransactionTest1</span><span class="params">()</span></span>{</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"47.102.124.75"</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Transaction transaction = jedis.multi();	<span class="comment">// 启动事务</span></span><br><span class="line">    transaction.set(<span class="string">"name"</span>, <span class="string">"yqx"</span>);</span><br><span class="line">    transaction.set(<span class="string">"age"</span>, <span class="string">"20"</span>);</span><br><span class="line">    transaction.incr(<span class="string">"name"</span>);					<span class="comment">// 测试错误语法</span></span><br><span class="line">    transaction.exec();</span><br><span class="line">    System.out.println(jedis.get(<span class="string">"name"</span>)); <span class="comment">// yqx</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransactionTest2</span><span class="params">()</span></span>{</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"47.102.124.75"</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Transaction transaction = jedis.multi();</span><br><span class="line">    <span class="comment">// 全都不会被执行</span></span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        transaction.set(<span class="string">"name"</span>, <span class="string">"yqx"</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"name"</span>));	</span><br><span class="line">        transaction.set(<span class="string">"age"</span>, <span class="string">"20"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        transaction.exec();</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        transaction.discard();					<span class="comment">// 事务执行失败，则取消事务</span></span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"name"</span>));	<span class="comment">// null</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">"age"</span>));	<span class="comment">// null</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="八、Redis-配置"><a href="#八、Redis-配置" class="headerlink" title="八、Redis 配置"></a>八、Redis 配置</h2><div class="note success">
            <p>Redis 单位不区分大小写</p>
          </div>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same</span><br></pre></td></tr></tbody></table></figure>
<div class="note success">
            <p>主要配置字段说明</p>
          </div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">配置项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>daemonize no</code></td>
<td style="text-align:left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>pidfile /var/run/redis.pid</code></td>
<td style="text-align:left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>port 6379</code></td>
<td style="text-align:left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>bind 127.0.0.1</code></td>
<td style="text-align:left">绑定的主机地址</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><code>timeout 300</code></td>
<td style="text-align:left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><code>loglevel notice</code></td>
<td style="text-align:left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><code>logfile stdout</code></td>
<td style="text-align:left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>databases 16</code></td>
<td style="text-align:left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><code>save &lt;seconds&gt; &lt;changes&gt;</code>Redis 默认配置文件中提供了三个条件：<strong>save 900 1**</strong>save 300 10<strong>**save 60 10000</strong>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td>
<td style="text-align:left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><code>rdbcompression yes</code></td>
<td style="text-align:left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><code>dbfilename dump.rdb</code></td>
<td style="text-align:left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><code>dir ./</code></td>
<td style="text-align:left">指定本地数据库存放目录</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td style="text-align:left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><code>masterauth &lt;master-password&gt;</code></td>
<td style="text-align:left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><code>requirepass foobared</code></td>
<td style="text-align:left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</password></td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><code>maxclients 128</code></td>
<td style="text-align:left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><code>maxmemory &lt;bytes&gt;</code></td>
<td style="text-align:left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><code>appendonly no</code></td>
<td style="text-align:left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><code>appendfilename appendonly.aof</code></td>
<td style="text-align:left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><code>appendfsync everysec</code></td>
<td style="text-align:left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><code>vm-enabled no</code></td>
<td style="text-align:left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><code>vm-swap-file /tmp/redis.swap</code></td>
<td style="text-align:left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><code>vm-max-memory 0</code></td>
<td style="text-align:left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><code>vm-page-size 32</code></td>
<td style="text-align:left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><code>vm-pages 134217728</code></td>
<td style="text-align:left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><code>vm-max-threads 4</code></td>
<td style="text-align:left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><code>glueoutputbuf yes</code></td>
<td style="text-align:left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td style="text-align:left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><code>activerehashing yes</code></td>
<td style="text-align:left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><code>include /path/to/local.conf</code></td>
<td style="text-align:left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody>
</table>
</div>
<h2 id="九、持久化"><a href="#九、持久化" class="headerlink" title="九、持久化"></a>九、持久化</h2><p>由于 Redis 的数据都是保存在内存中的，因此如果哪儿天服务器宕机了，那么所有的数据就都消失了，这是绝对不会被允许的！！！因此需要持久化到硬盘中。</p>
<p><img src="https://z3.ax1x.com/2021/11/26/oZyOTs.png" alt=""></p>
<p><br></p>
<h4 id="9-1、RDB-持久化"><a href="#9-1、RDB-持久化" class="headerlink" title="9.1、RDB 持久化"></a>9.1、RDB 持久化</h4><p><strong>RDB</strong> 持久化就是每过一个周期，就将内存中的数据全都遍历一遍并写入到文件中，而且为了节省空间，定义了一个二进制的格式进行存储，将数据一条一条连在一起，生成了一个 <strong>RDB</strong> 文件。</p>
<p><img src="https://z3.ax1x.com/2021/11/26/oZ6F0J.png" alt=""></p>
<p>那么该如何设置保存周期呢？在 Redis 的 config 文件中，有着如下三行内容，可以按需进行修改。多个条件可以组合使用，只要下面其中一个条件满足，Redis 就会去进行备份。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1    # 900秒（15分钟）内有1个写入</span><br><span class="line">save 300 10   # 300秒（5分钟）内有10个写入</span><br><span class="line">save 60 10000 # 60秒（1分钟）内有10000个写入</span><br></pre></td></tr></tbody></table></figure>
<p>那么如果在保存数据库文件的时候，又有新的请求该怎么办呢？很自然而然地，就能想到可以 <strong>fork</strong> 出一个子线程来做备份数据库的事情。</p>
<p>但是啊，周期性地备份文件有一个致命性的问题，那就是周期时间——<strong>竟然是分钟级别</strong>！！！如果出现停机等问题，还是会损失这一分钟内的数据。诚然，你也可以设置成每秒钟备份一次，那效率就太低下了。</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oZc5M8.png" alt=""></p>
<p>由此，我们引出了新的概念—— AOF。</p>
<p><br></p>
<h4 id="9-2、AOF-持久化"><a href="#9-2、AOF-持久化" class="headerlink" title="9.2、AOF 持久化"></a>9.2、AOF 持久化</h4><p>AOF 全称 <strong>Append Only File</strong>（只追加文件），类似于 mysql 的二进制日志 binlog。<strong>其原理就是记录数据更改的操作（不包括查询），而不是记录数据本身。</strong>毕竟只要记录数据在这一段时间内是如何修改的，那之后也能通过执行这个 AOF 文件还原回去。</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oZgYy8.png" alt=""></p>
<p>那么 AOF 应该多久写一次文件呢？</p>
<p>肯定不能每执行一条修改命令就记录到文件中，IO 操作十分昂贵，这回严重拖垮数据库性能！因此需要准备一个缓冲区，将要记录的命令先临时保存在这里，再择机写入文件，我把这个临时缓冲区叫做 <strong>aof_buf</strong>。</p>
<p>具体如何设置刷新周期可以在 Redis 的配置文件中进行修改。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br><span class="line"></span><br><span class="line">always: 每个事件周期都同步刷新一次</span><br><span class="line">everysec(默认): 每一秒都同步刷新一次</span><br><span class="line">no: 我只管写，让操作系统自己决定什么时候真正写入吧</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4px">AOF 重写</font></strong></p>
<p>但是正如其名，只追加文件只会追加数据，这就会导致随着时间的推移，这个 <strong>AOF</strong> 备份文件会越来越大！！！不仅非常占硬盘空间，复制移动，加载分析等操作都异常麻烦耗时。</p>
<p>这就需要对 <strong>AOF</strong> 文件进行<code>压缩</code>，也就是 <strong>AOF</strong> 重写。</p>
<p>观察以下命令，是不是非常冗余！</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name yqx</span><br><span class="line"><span class="built_in">set</span> name deflory</span><br><span class="line"><span class="built_in">set</span> name SuicideKing</span><br><span class="line"><span class="built_in">set</span> name DreamFragrance</span><br></pre></td></tr></tbody></table></figure>
<p>将每次修改操作都记录下来导致文件过大，而且数据改来改去，很多中间状态根本没有用，只需要记录最终的状态即可，这就是 <strong>AOF</strong> 重写的思想。</p>
<p>因此上述命令只需要一行即可记录完毕。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name DreamFragrance</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://z3.ax1x.com/2021/11/27/oZRigx.png" alt="image"></p>
<p>同 RDB 一样，IO 操作总是代价昂贵的，因此要 <strong>fork</strong> 一个子进程来重写文件。</p>
<p><strong>但是，这样就真的没有问题了吗？</strong></p>
<p>如果在重写 AOF 文件的时候，新的数据被修改了，那岂不是会出现数据库数据和重写内容不一致的情况吗？</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oZReVe.png" alt="image"></p>
<p>于是，继之前的 <strong>aof_buf</strong>，Redis 又准备了一个新的缓冲区—— <strong>AOF 重写缓冲区</strong>。</p>
<p>从创建重写 <strong>AOF</strong> 子进程的那个一刻起，Redis 将后面来的写入命令都复制到这个重写缓冲区中，等到子进程重写 <strong>AOF</strong> 文件结束以后，再将这个缓冲区的文件写入到新的 AOF 文件中。</p>
<p>最后再将这个崭新的 AOF 文件替换掉原先那个冗余的 AOF 文件，整个重写过程就算大功告成了！</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oZRHde.png" alt="image"></p>
<p><br></p>
<h4 id="9-3、详解-RDB-和-AOF"><a href="#9-3、详解-RDB-和-AOF" class="headerlink" title="9.3、详解 RDB 和 AOF"></a>9.3、详解 RDB 和 AOF</h4><p><strong><font size="4px">Redis 持久化：</font></strong></p>
<p>Redis 提供了多种不同级别的持久化方式：一种是 <strong>RDB</strong>,另一种是 <strong>AOF</strong>。</p>
<p>RDB 持久化可以在<strong>指定的时间间隔内生成数据集的时间点快照</strong>（point-in-time snapshot）。</p>
<p><strong>AOF 持久化记录服务器执行的所有写操作命令</strong>，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p>
<p><strong><font size="4px">RDB 的优点：</font></strong></p>
<p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p><strong><font size="4px">RDB 的缺点：</font></strong></p>
<p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， <strong>因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。</strong> 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； <strong>如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</strong></p>
<p><strong><font size="4px">AOF 的优点：</font></strong></p>
<p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题，至于是如何修复的嘛，只是把有问题的命令删去而已。既然解决不了问题，那就解决掉提出问题的人。<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
<p><strong><font size="4px">AOF 的缺点：</font></strong></p>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p>
<p><strong><font size="4px">RDB 和 AOF 该如何选择？</font></strong></p>
<p>一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。因为以上提到的种种原因， 未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）</p>
<p><strong><font size="4px">RDB 快照：</font></strong></p>
<p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></tbody></table></figure>
<p>这种持久化方式被称为快照（snapshot）。</p>
<p><strong><font size="4px">快照的运作方式：</font></strong></p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：<br>Redis 调用 fork() ，同时拥有父进程和子进程。<br>子进程将数据集写入到一个临时 RDB 文件中。<br>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。<br>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。<br>只进行追加操作的文件（append-only file，AOF）<br>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。<br>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。<br>你可以通过修改配置文件来打开 AOF 功能：<br>appendonly yes<br>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。<br>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
<p><strong><font size="4px">快照的运作方式：</font></strong></p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：<br>Redis 调用 fork() ，同时拥有父进程和子进程。<br>子进程将数据集写入到一个临时 RDB 文件中。<br>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。<br>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。<br>只进行追加操作的文件（append-only file，AOF）<br>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。<br>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。<br>你可以通过修改配置文件来打开 AOF 功能：<br>appendonly yes<br>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。<br>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
<p><strong><font size="4px">AOF 重写：</font></strong></p>
<p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p>
<p><strong><font size="4px">如果 AOF 出错了：</font></strong></p>
<p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p>
<p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p>
<ol>
<li><p>为现有的 AOF 文件创建一个备份。</p>
</li>
<li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处（可选）。</p>
</li>
<li><p>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</p>
</li>
</ol>
<p><strong>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</strong></p>
<p><strong><font size="4px">AOF 重写的执行步骤：</font></strong></p>
<p>Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>子进程开始将新 AOF 文件的内容写入到临时文件。对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p>
<p><strong><font size="4px">RDB 和 AOF 之间的相互作用：</font></strong></p>
<p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。<br>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。<br>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p>
<p><strong><font size="4px">备份 Redis 数据：</font></strong></p>
<p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 原子地用临时文件替换原来的 RDB 文件。这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p>
<h2 id="十、发布订阅"><a href="#十、发布订阅" class="headerlink" title="十、发布订阅"></a>十、发布订阅</h2><h4 id="10-1、什么是发布订阅？"><a href="#10-1、什么是发布订阅？" class="headerlink" title="10.1、什么是发布订阅？"></a>10.1、什么是发布订阅？</h4><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oeNpJe.png" alt="image"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oeNCzd.png" alt="image"></p>
<p><br></p>
<p>要想在 Redis 中模拟发布订阅的过程，需要开启两个 redis-cli 客户端。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅channel1频道</span></span><br><span class="line">127.0.0.1:6379&gt; subscribe channel1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"channel1"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 频道channel1发布消息，“hello，it's channel1”</span></span><br><span class="line">127.0.0.1:6379&gt; publish channel1 <span class="string">"hello,it's channel1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户收到来自channel1的消息</span></span><br><span class="line">127.0.0.1:6379&gt; subscribe channel1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"channel1"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"channel1"</span></span><br><span class="line">3) <span class="string">"hello,it's channel1"</span></span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<h4 id="10-2、发布订阅常用命令"><a href="#10-2、发布订阅常用命令" class="headerlink" title="10.2、发布订阅常用命令"></a>10.2、发布订阅常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h4 id="10-3、原理"><a href="#10-3、原理" class="headerlink" title="10.3、原理"></a>10.3、原理</h4><p>Redis 是使用 C 实现的，通过分析 Redis 源码里的 public.c 文件，了解发布和订阅机制的底层实现，借此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过 PUBLISH 命令向订阅者发送信息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找订阅了这个频道所有的客户端链表，借此将消息发布给所有的订阅者。</p>
<p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subcribe），在Redis中，你可以设定对某一个 key 进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会受到相应的信息。这一功能最明显的用法就是用作实时消息系统，例如群聊等。</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oeaKrn.jpg" alt="v2 76e3e06285cdeea65abf6877497be3f1 720w"></p>
<h2 id="十一、主从复制"><a href="#十一、主从复制" class="headerlink" title="十一、主从复制"></a>十一、主从复制</h2><h4 id="11-1、简介"><a href="#11-1、简介" class="headerlink" title="11.1、简介"></a>11.1、简介</h4><p>主从复制是为了达成高可用</p>
<ul>
<li>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服<br>务器上，连接在一起，并保证数据是同步的。</li>
<li>即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/11/27/oeysv8.png" alt="image"></p>
<ul>
<li>提供数据方：master<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动同步到slave</li>
<li>读数据（可忽略）</li>
<li>一个master可以拥有多个slave</li>
</ul>
</li>
<li>接收数据方：slave<ul>
<li>读数据</li>
<li>写数据（禁止）</li>
<li>一个slave只对应一个master</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li>数据同步</li>
</ul>
</li>
<li>核心工作<ul>
<li>master的数据复制到slave中</li>
</ul>
</li>
</ul>
<h4 id="11-2、作用"><a href="#11-2、作用" class="headerlink" title="11.2、作用"></a>11.2、作用</h4><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower) ; 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点 ;</p>
<p>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p>其作用有以下五点：</p>
<ol>
<li><strong>读写分离</strong>：主节点写，从节点读，提高服务器的读写负载能力</li>
<li><strong>数据冗余</strong>︰主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复</strong>︰当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 ; 实际上是一种服务的冗余。</li>
<li><strong>负载均衡</strong>︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载 ; 尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li><strong>高可用（集群）基石</strong>︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<h4 id="11-3、环境搭建"><a href="#11-3、环境搭建" class="headerlink" title="11.3、环境搭建"></a>11.3、环境搭建</h4><p>这里我们实现的是<code>一主二从</code>，先准备三份配置文件，因为是根据配置文件创建服务的。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory redis-6.2.6]<span class="comment"># mkdir master-slaver-config</span></span><br><span class="line">[root@deflory redis-6.2.6]<span class="comment"># cp MyRedis.conf master-slaver-config/redis79.config</span></span><br><span class="line">[root@deflory redis-6.2.6]<span class="comment"># cp MyRedis.conf master-slaver-config/redis80.config</span></span><br><span class="line">[root@deflory redis-6.2.6]<span class="comment"># cp MyRedis.conf master-slaver-config/redis81.config</span></span><br></pre></td></tr></tbody></table></figure>
<p>每个配置文件都需要修改一下四个地方。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6379	<span class="comment"># 端口号</span></span><br><span class="line">pidfile /var/run/redis_6379.pid	<span class="comment"># 后台进程文件</span></span><br><span class="line">logfile <span class="string">"6379.log"</span>	<span class="comment"># 日志文件</span></span><br><span class="line">dbfilename dump6379.rdb	<span class="comment"># 备份文件</span></span><br></pre></td></tr></tbody></table></figure>
<p>开启三个服务器端。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ./redis-server ../master-slaver-config/redis79.config </span></span><br><span class="line">[root@deflory src]<span class="comment"># ./redis-server ../master-slaver-config/redis80.config </span></span><br><span class="line">[root@deflory src]<span class="comment"># ./redis-server ../master-slaver-config/redis81.config </span></span><br></pre></td></tr></tbody></table></figure>
<p>查看后台进程。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ps -ef | grep redis</span></span><br><span class="line">root      3526     1  0 Nov26 ?        00:02:25 ./redis-server *:6379</span><br><span class="line">root     10786     1  0 15:54 ?        00:00:00 ./redis-server *:6380</span><br><span class="line">root     10848     1  0 15:54 ?        00:00:00 ./redis-server *:6381</span><br><span class="line">root     11456 27951  0 15:54 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<h4 id="11-4、主从复制实战"><a href="#11-4、主从复制实战" class="headerlink" title="11.4、主从复制实战"></a>11.4、主从复制实战</h4><p>连接服务器端，使用 <code>info replication</code> 来查看当前主从情况。</p>
<p>由于服务器默认都是以主机启动的，因此目前“三台机器”都是主机。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master			<span class="comment"># 角色为主机</span></span><br><span class="line">connected_slaves:0	<span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1c16ac389c930c4f0bec48f654f4aea35c83975e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>slaveof host port</code> 来连接主机，如果主机有设置密码，则会要求进行 auth 验证。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication	<span class="comment"># 从机的主从信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:1</span><br><span class="line">slave_read_repl_offset:1</span><br><span class="line">slave_repl_offset:1</span><br><span class="line">master_sync_total_bytes:-1</span><br><span class="line">master_sync_read_bytes:0</span><br><span class="line">master_sync_left_bytes:-1</span><br><span class="line">master_sync_perc:-0.00</span><br><span class="line">master_sync_last_io_seconds_ago:0</span><br><span class="line">master_link_down_since_seconds:-1</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:54b564a0c9ce365c28c6cfdad02b242bd1bd43b1</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></tbody></table></figure>
<p>主机的主从信息。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2	<span class="comment"># 连接了两个从机</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=wait_bgsave,offset=0,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=wait_bgsave,offset=0,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1a9562c7e236c63f924abd1bdad46192f466337d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:70</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:70</span><br></pre></td></tr></tbody></table></figure>
<p><br></p>
<p><strong><font size="4px">运行测试</font></strong></p>
<p>在主机写入<strong>name:deflory</strong>后，从机也能读取到相应内容。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机写入</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name deflory</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"deflory"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从机1读取</span></span><br><span class="line">127.0.0.1:6380&gt; get name</span><br><span class="line"><span class="string">"deflory"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从机2读取</span></span><br><span class="line">127.0.0.1:6381&gt; get name</span><br><span class="line"><span class="string">"deflory"</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，从机只能用来读取数据，而不能修改数据，只读！</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> age 10</span><br><span class="line">(error) READONLY You can<span class="string">'t write against a read only replica.</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>那么如果此时，我们的主机宕机了会发生什么呢？</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机宕机</span></span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使主机宕机了，由于数据已经复制到从机上了，因此仍然可以查询到</span></span><br><span class="line">127.0.0.1:6380&gt; get name</span><br><span class="line"><span class="string">"deflory"</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>接下来我们换个角度，从机宕机呢？</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从机1宕机</span></span><br><span class="line">127.0.0.1:6380&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机写入数据</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从机2仍然可以正常读取数据</span></span><br><span class="line">127.0.0.1:6381&gt; get age</span><br><span class="line"><span class="string">"20"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新连接从机1</span></span><br><span class="line">[root@deflory src]<span class="comment"># ./redis-server ../master-slaver-config/redis80.config </span></span><br><span class="line">[root@deflory src]<span class="comment"># ./redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; clear</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于之前我们是在命令行中设置主从机，因此重启之后就又默认成为了主机</span></span><br><span class="line"><span class="comment"># 想要实现重启还是从机的话，需要在配置文件中修改</span></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:e2f04142dad9c956952dd6cc62d27db9f654bf14</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新设置主机</span></span><br><span class="line">127.0.0.1:6380&gt; replicaof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get age	<span class="comment"># 从机在连接主机时会进行全量复制，因此宕机再连接还是可以查询到信息的</span></span><br><span class="line"><span class="string">"20"</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note success">
            <p>注：配置文件主从复制设置</p><p>在5.0.0之后，slaveof 逐渐被 replicaof 所取代，因此在配置文件中也不叫 slaveof 了，找了我好久！！！</p>
          </div>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置主机ip和端口</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If the master is password protected (using the "requirepass" configuration</span></span><br><span class="line"><span class="comment"># directive below) it is possible to tell the replica to authenticate before</span></span><br><span class="line"><span class="comment"># starting the replication synchronization process, otherwise the master will</span></span><br><span class="line"><span class="comment"># refuse the replica request.</span></span><br><span class="line"><span class="comment"># 如果主机有密码，需要进行auth认证</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>不过，就正常而言，如果主机宕机了，剩下的从机是无法进行写入操作的，因此一个比较好的解决方案，就是从剩下的从机中，再选出一个主机。</strong></p>
<p><br></p>
<h4 id="11-5、链式主从模式"><a href="#11-5、链式主从模式" class="headerlink" title="11.5、链式主从模式"></a>11.5、链式主从模式</h4><p>即如下设计结构，中间的服务器既是前面的从服务器，也是后面的主服务器。</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oejcsU.png" alt=""></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器1，角色：master，有一个slaver</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=44034,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:87d1dd88912bc43511d8542553412c7047692e75</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:44034</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:44034</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器2，角色：slaver，有一个slaver</span></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:44020</span><br><span class="line">slave_repl_offset:44020</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=44020,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:87d1dd88912bc43511d8542553412c7047692e75</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:44020</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1650</span><br><span class="line">repl_backlog_histlen:42371</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器3，角色：slaver，没有slaver，处于该链的末尾</span></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:5</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:44006</span><br><span class="line">slave_repl_offset:44006</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:87d1dd88912bc43511d8542553412c7047692e75</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:44006</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:44006</span><br></pre></td></tr></tbody></table></figure>
<p>测试，主服务器写入数据，后面两个从服务器都能读取数据。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name yqx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get name</span><br><span class="line"><span class="string">"yqx"</span></span><br><span class="line">127.0.0.1:6381&gt; get name</span><br><span class="line"><span class="string">"yqx"</span></span><br></pre></td></tr></tbody></table></figure>
<p>但当主服务器宕机后，第二台服务器依旧不能写入数据。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> weight 60</span><br><span class="line">(error) READONLY You can<span class="string">'t write against a read only replica</span></span><br></pre></td></tr></tbody></table></figure>
<p>需要使用 <code>replicaof no one</code>，来将自己提升为主服务器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; replicaof no one</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=28,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:ae7b3b6cbc8f62fbcb8d179325de0e83afe61701</span><br><span class="line">master_replid2:78124558cc7e470c3eca6b2517ffbc3a0a6557a7</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:15</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> weight 666</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 此时处于末尾的从服务器也能获取到刚刚设置的体重值</span></span><br><span class="line">127.0.0.1:6381&gt; get weight</span><br><span class="line"><span class="string">"666"</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note danger">
            <p>但是这种类似链式的主从复制模型，有着三个非常大的问题！！！</p>
          </div>
<ul>
<li>如果中间的某台服务器宕机了，那么后面的服务器就无法再接受到更新的数据了！</li>
<li>由于数据是像链式一样进行更新，处于末尾的从服务器会和前面的服务器的更新时间差距很大！</li>
<li>每次都要手动的选择主服务器，效率非常低！</li>
</ul>
<p><br></p>
<h4 id="11-6、主从复制运行原理"><a href="#11-6、主从复制运行原理" class="headerlink" title="11.6、主从复制运行原理"></a>11.6、主从复制运行原理</h4><p>Slave 启动成功连接到 master 后会发送一个 sync 同步指令</p>
<p>Master 接到指令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave 并完成一次完全同步。</p>
<p>全量复制：slave 在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制：Master 继续将新的所有收集到的修改命令一次传给 slave ，完成同步。</p>
<p>只要是重新连接到 Master，就会进行一次完全同步（全量复制 + 增量复制）。</p>
<p><img src="https://z3.ax1x.com/2021/11/27/oeXVBQ.png" alt="image"></p>
<p><strong><font size="5px">增量复制实现</font></strong></p>
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区（replication backlog）</li>
<li>服务器运行ID（run ID）</li>
</ul>
<div class="note success">
            <p><strong>复制偏移量</strong></p>
          </div>
<p>执行复制的双方——主服务器和从服务器分别维护着一个对应的复制偏移量。</p>
<ul>
<li>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N。</li>
<li>从服务器每次收到主服务器传来的 N 个字节的数据时，也将自己的复制偏移量的值加上 N。</li>
</ul>
<p>通过对比主从服务器的复制偏移量，程序很容易就能知道主从服务器是否处于同一个状态。</p>
<ul>
<li>如果主从服务器处于一致的状态，那么他们的复制偏移量总是相同的。</li>
<li>相反，如果主从服务器的复制偏移量不相同，那么他们就并未处于一致的状态</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/11/28/ouNngg.png" alt="image"></p>
<div class="note success">
            <p><strong>复制积压缓冲区</strong></p>
          </div>
<p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出的队列，默认大小为1MB。固定长度的先入先出队列不能随着元素的增加和减少而动态的调整长度，固定长度先进先出队列的长度是固定的，<strong>当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</strong>。</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会降所有写命令入队到复制积压缓冲区里面，如图所示：</p>
<p><img src="https://z3.ax1x.com/2021/11/28/ouNUv4.png" alt="image"></p>
<p><strong>重连同步流程：</strong></p>
<ol>
<li>当从服务器A(上图为例)断线重连后，向主服务器发送PSYNC命令，报告自己的偏移量为10086。</li>
<li>主服务器收到命令后，检查偏移量10086之后的数据是否存在于复制积压缓冲区里。存在，向服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式进行。（不存在，主服务器将对从服务器执行完整重同步操作）。</li>
<li>主服务器将复制积压缓冲区10086之后的所有数据发送给从服务器。</li>
<li>从服务器接收缺失数据，回到与主服务器一致的状态。</li>
</ol>
<p>因此，主服务器的复制积压缓冲区会存放近期传播过的写命令，并且<strong>复制积压缓冲区会为队列中的每个字节记录响应的复制偏移量</strong>。</p>
<p>当从服务器重新连接上主服务器时，从服务器会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据从服务器的复制偏移量来决定对从服务器执行何种同步操作。</p>
<ul>
<li>如果偏移量 offset 之后的数据仍然处于复制积压缓冲区里，那么主服务器将会对从服务器执行部分同步操作（增量复制）。</li>
<li>如果偏移量 offset 之后的数据已经不存在于复制积压缓冲区中，那么主服务器将会对从服务器执行完整同步操作（全量复制）。</li>
</ul>
<div class="note success">
            <p><strong>服务器运行 ID</strong></p>
          </div>
<p>除了复制偏移量和复制积压缓冲区之外，是部分重同步还需要用到服务器 ID：</p>
<ul>
<li>每个 Redis 服务器，不论是主服务器还是从服务器，都会有自己的运行 ID</li>
<li>运行 ID 在服务器启动时自动生成，由40个随机的十六进制地府组成</li>
</ul>
<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传递给从服务器，从服务器则会将这个运行 ID 保存起来。当从服务器断线并重新连接到主服务器时，从服务器就会比对之前连接的主服务器的运行 ID：</p>
<ul>
<li>如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 一致，说明从服务器现在与之前连接的主服务器都是一个服务器，主服务器可以继续尝试执行部分重同步的操作。</li>
<li>如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 不一致，说明在从服务器断连的这一段时间里，已经更换了一个主服务器，现在的主服务器需要对从服务器执行完整的重同步操作。</li>
</ul>
<div class="note success">
            <p><strong>PSYNC 命令的实现</strong></p>
          </div>
<p>PSYNC 命令的调用方式有两种：</p>
<ul>
<li>如果从服务器之前从来没有复制过任何主服务器，或者之前没有执行过 <code>slaveof no one</code> 命令，那么从服务器则会向主服务器发送 PSYNC? -1命令，主动请求服务器进行完整重同步</li>
<li>相反的，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时，将向主服务器发送 PSYNC runid offset 命令：其中 runid 是上一次复制的主服务器的运行 ID，而 offset 则是从服务器当前的复制偏移量，接收到这个命令的主服务器会根据这两个参数来判断对该从服务器执行哪儿中同步操作。<ul>
<li>如果主服务器返回 <code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，那么则表示主服务器将与从服务器进行完整重同步： 其中 runid 是当前主服务器的运行 ID，从服务器需将这个 ID 保存起来，再下一次发送 PASYNC 时使用；而 offset 则是当前主服务器的复制偏移量，而从服务器则会将这个值作为自己的初始化复制偏移量。</li>
<li>如果主服务器返回 <code>+Continue</code>，那么表示主服务器将与从服务器进行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来即可！</li>
<li>如果主服务器返回 <code>-ERR</code>，表示当前的主服务器版本低于2.8，它识别不了 PSYNC 命令，从服务器将向主服务器发送 SYNC 命令，并且与主服务器执行完全重同步操作。</li>
</ul>
</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/11/28/ouNIat.png" alt=""></p>
<div class="note success">
            <p><strong>心跳检测</strong></p>
          </div>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率。像主服务器发送命令：<code>REPLCONF ACK &lt;offset&gt;</code>，其中 <code>offset</code> 是从服务器当前的复制偏移量。</p>
<p>作用：</p>
<ul>
<li><p>检测 主从服务器的网络连接状态</p>
</li>
<li><p>辅助实现 <strong>min-slaves</strong> 选项，min-slaves-to-write 和 min-slaves-max-lag 都是为了防止主服务器在不安全的情况下执行写命令。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></tbody></table></figure>
<p>在从服务器数量小于3个，或者三个从服务器的延迟值（最后一次心跳检测距离现在过了多少秒）都大于等于十秒时，主服务器将拒绝执行写命令。</p>
</li>
<li><p>检测命令丢失。偏移量不一致时，会进行补发缺失数据的操作。</p>
</li>
</ul>
<p><br></p>
<h4 id="11-7、哨兵模式（Sentinel）【推荐】"><a href="#11-7、哨兵模式（Sentinel）【推荐】" class="headerlink" title="11.7、哨兵模式（Sentinel）【推荐】"></a>11.7、哨兵模式（Sentinel）【推荐】</h4><p>上述主从切换技术的方法，主要是通过在主服务器宕机的时候，人工手动地将某台从服务器切换成主服务器，再将其余的从服务器都配置成它的 slaver。<strong>这整一个过程需要人工干预，费时又费力，还会造成一段时间内的服务不可用</strong>。不推荐！</p>
<p>因此就有了<strong>哨兵模式</strong>。</p>
<div class="note success">
            <p><strong>什么是哨兵模式？</strong></p>
          </div>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
<p><img src="https://z3.ax1x.com/2021/11/28/oucAVU.png" alt="image"></p>
<p>这里哨兵有三个作用：</p>
<ul>
<li><strong>监控（Monitoring）</strong>：Sentinel 会不断检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>：当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automotic failover）</strong>：当一个主服务器不能正常工作时，Sentinel 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其它从服务器也改为新的主服务器的从服务器。而当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器来代替失效的服务器。</li>
</ul>
<p>诶，可是如果这个哨兵进程宕机了，整个系统不就崩盘了吗？</p>
<p>为此，我们可以使用多个哨兵进行监控。各个哨兵之间也会互相监控，这样就形成了多哨兵模式。</p>
<p><img src="https://z3.ax1x.com/2021/11/28/ougD61.png" alt="image"></p>
<p>这里简单用文字描述一下<strong>故障切换（failover）</strong>的过程。</p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观地认为主服务器不可用，这个现象被称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就行进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅的方式，让各个哨兵把自己监控的从服务器实现切换主机，在个过程成为<strong>客观下线</strong>，这样对于客户端而言，一切都是透明的。</p>
<div class="note success">
            <p><strong>每个 Sentinel 都需要定期执行的任务</strong></p>
          </div>
<ul>
<li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</li>
<li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li>
<li>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li>
<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主观下线状态就会被移除。</li>
</ul>
<div class="note success">
            <p><strong>自动发现 Sentinel 和从服务器</strong></p>
          </div>
<p>一个 Sentinel 可以与其他多个 Sentinel 进行连接， 各个 Sentinel 之间可以互相检查对方的可用性， 并进行信息交换。</p>
<p>你无须为运行的每个 Sentinel 分别设置其他 Sentinel 的地址， 因为 Sentinel 可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他 Sentinel ， 这一功能是通过向频道 <strong>sentinel:hello</strong> 发送信息来实现的。</p>
<p>与此类似， 你也不必手动列出主服务器属下的所有从服务器， 因为 Sentinel 可以通过询问主服务器来获得所有从服务器的信息。</p>
<ul>
<li>每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 <strong>sentinel:hello</strong> 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。</li>
<li>每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 <strong>sentinel:hello</strong> 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。</li>
<li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li>
<li>在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel 。</li>
</ul>
<div class="note success">
            <p><strong>故障转移</strong></p>
          </div>
<p>一次故障转移操作由以下步骤组成：</p>
<ul>
<li>发现主服务器已经进入客观下线状态。</li>
<li>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</li>
<li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</li>
<li>选出一个从服务器，并将它升级为主服务器。</li>
<li>向被选中的从服务器发送 <code>SLAVEOF NO ONE</code> 命令，让它转变为主服务器。</li>
<li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li>
<li>向已下线主服务器的从服务器发送 <strong>SLAVEOF</strong> 命令， 让它们去跟随新的主服务器。</li>
<li>当所有从服务器都已经开始跟随新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li>
</ul>
<p>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</p>
<p>Sentinel 使用以下规则来选择新的主服务器：</p>
<ul>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li>
<li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li>
</ul>
<div class="note success">
            <p><strong>Sentinel 自动故障迁移的一致性特质</strong></p>
          </div>
<p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p>
<p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p>
<p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p>
<p>简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p>
<p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p>
<p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p>
<div class="note success">
            <p><strong>Sentinel 状态的持久化</strong></p>
          </div>
<p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。</p>
<p>每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。</p>
<p>这意味着停止和重启 Sentinel 进程都是安全的。</p>
<div class="note success">
            <p><strong>Sentinel 在非故障迁移的情况下对实例进行重新配置</strong></p>
          </div>
<p>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p>
<ul>
<li>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。 那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。</li>
</ul>
<p>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</p>
<div class="note success">
            <p><strong>TILT 模式</strong></p>
          </div>
<p>Redis Sentinel 严重依赖计算机的时间功能： 比如说， 为了判断一个实例是否可用， Sentinel 会记录这个实例最后一次相应 PING 命令的时间， 并将这个时间和当前时间进行对比， 从而知道这个实例有多长时间没有和 Sentinel 进行任何成功通讯。</p>
<p>不过， 一旦计算机的时间功能出现故障， 或者计算机非常忙碌， 又或者进程因为某些原因而被阻塞时， Sentinel 可能也会跟着出现故障。</p>
<p>TILT 模式是一种特殊的保护模式： 当 Sentinel 发现系统有些不对劲时， Sentinel 就会进入 TILT 模式。</p>
<p>因为 Sentinel 的时间中断器默认每秒执行 10 次， 所以我们预期时间中断器的两次执行之间的间隔为 100 毫秒左右。 Sentinel 的做法是， 记录上一次时间中断器执行时的时间， 并将它和这一次时间中断器执行的时间进行对比：</p>
<ul>
<li>如果两次调用时间之间的差距为负值， 或者非常大（超过 2 秒钟）， 那么 Sentinel 进入 TILT 模式。</li>
<li>如果 Sentinel 已经进入 TILT 模式， 那么 Sentinel 延迟退出 TILT 模式的时间。</li>
</ul>
<p>当 Sentinel 进入 TILT 模式时， 它仍然会继续监视所有目标， 但是：</p>
<ul>
<li>它不再执行任何操作，比如故障转移。</li>
<li>当有实例向这个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令时， Sentinel 返回负值： 因为这个 Sentinel 所进行的下线判断已经不再准确。</li>
</ul>
<p>如果 TILT 可以正常维持 30 秒钟， 那么 Sentinel 退出 TILT 模式。</p>
<div class="note success">
            <p><strong>处理 -BUSY 状态</strong></p>
          </div>
<p>当 Lua 脚本的运行时间超过指定时限时， Redis 就会返回 -BUSY 错误。</p>
<p>当出现这种情况时， Sentinel 在尝试执行故障转移操作之前， 会先向服务器发送一个 SCRIPT KILL 命令， 如果服务器正在执行的是一个只读脚本的话， 那么这个脚本就会被杀死， 服务器就会回到正常状态。</p>
<h4 id="11-8、哨兵模式实战"><a href="#11-8、哨兵模式实战" class="headerlink" title="11.8、哨兵模式实战"></a>11.8、哨兵模式实战</h4><p>创建配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵实例运行端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵工作目录</span></span><br><span class="line">/tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># quorum 表示有多少哨兵认为主服务器主观下线时，那么这时主服务器就变成了客观下线</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></tbody></table></figure>
<p><strong>哨兵模式配置参数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置项</th>
<th>参数类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>整数</td>
<td>启动哨兵进程端口</td>
</tr>
<tr>
<td>dir</td>
<td>文件夹目录</td>
<td>哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds</td>
<td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td>
</tr>
<tr>
<td>sentinel parallel-syncs</td>
<td>&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td>
<td>指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td>
</tr>
<tr>
<td>sentinel failover-timeout</td>
<td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td>
</tr>
<tr>
<td>sentinel notification-script</td>
<td>&lt;服务名称&gt;&lt;脚本路径&gt;</td>
<td>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td>
</tr>
</tbody>
</table>
</div>
<p><strong>运行哨兵进程</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ./redis-sentinel ../master-slaver-config/sentinel.conf </span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>查看哨兵进程</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@deflory src]<span class="comment"># ps -ef|grep sentinel</span></span><br><span class="line">root     14853     1  0 20:54 ?        00:00:00 ./redis-sentinel *:26379 [sentinel]</span><br><span class="line">root     15149 28363  0 20:54 pts/2    00:00:00 grep --color=auto sentinel</span><br></pre></td></tr></tbody></table></figure>
<p>接下来配置主从复制，这里我们仍然选择<strong>一主二从</strong>的模式。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=25982,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6380,state=online,offset=25982,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:3c7139ce2e8248ef2ea5d79c00387b3356c16e14</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:25982</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:72</span><br><span class="line">repl_backlog_histlen:25911</span><br></pre></td></tr></tbody></table></figure>
<p>关闭主服务器（端口6379），哨兵进程就开始工作了，将主服务器的身份移给了从服务器（端口6380）。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32507:X 28 Nov 2021 21:06:51.180 <span class="comment"># +failover-end master mymaster 127.0.0.1 6379</span></span><br><span class="line">32507:X 28 Nov 2021 21:06:51.180 <span class="comment"># +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=37163,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:c8d0b6a5529667f15d6322888a45a8f42ca1e5b9</span><br><span class="line">master_replid2:3c7139ce2e8248ef2ea5d79c00387b3356c16e14</span><br><span class="line">master_repl_offset:37296</span><br><span class="line">second_repl_offset:36595</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:22964</span><br><span class="line">repl_backlog_histlen:14333</span><br></pre></td></tr></tbody></table></figure>
<p>紧接着我再把当前新的主服务器关闭，现在只剩一台服务器，理所当然就成为了主服务器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32507:X 28 Nov 2021 21:09:07.218 <span class="comment"># +failover-end master mymaster 127.0.0.1 6380</span></span><br><span class="line">32507:X 28 Nov 2021 21:09:07.218 <span class="comment"># +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8203b47d316f6e313b7512a9d78c9ea12ff10d42</span><br><span class="line">master_replid2:c8d0b6a5529667f15d6322888a45a8f42ca1e5b9</span><br><span class="line">master_repl_offset:44095</span><br><span class="line">second_repl_offset:43674</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:13301</span><br><span class="line">repl_backlog_histlen:30795</span><br></pre></td></tr></tbody></table></figure>
<p>此时再将原来的主服务器（端口6379）重新连接，直接就变成了现主服务器的从服务器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32507:X 28 Nov 2021 21:11:08.150 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6381</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:63627</span><br><span class="line">slave_repl_offset:63627</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8203b47d316f6e313b7512a9d78c9ea12ff10d42</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:63627</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:51544</span><br><span class="line">repl_backlog_histlen:12084</span><br></pre></td></tr></tbody></table></figure>
<p>原来的从服务器（端口6380）就更是如此了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32507:X 28 Nov 2021 21:14:49.324 * +convert-to-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6381</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:69747</span><br><span class="line">slave_repl_offset:69747</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8203b47d316f6e313b7512a9d78c9ea12ff10d42</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:69747</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:66211</span><br><span class="line">repl_backlog_histlen:3537</span><br></pre></td></tr></tbody></table></figure>
<h2 id="十二、缓存问题"><a href="#十二、缓存问题" class="headerlink" title="十二、缓存问题"></a>十二、缓存问题</h2><h4 id="11-1、缓存雪崩"><a href="#11-1、缓存雪崩" class="headerlink" title="11.1、缓存雪崩"></a>11.1、缓存雪崩</h4><p>当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>
<p><img src="https://z3.ax1x.com/2021/11/28/ouvfZ8.png" alt=""></p>
<p><strong><font size="4px">分析：</font></strong></p>
<p>造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是 Redis 宕机，第二种可能是采用了相同的过期时间（购物节零点秒杀，大量商品同时失效）。搞清楚原因之后，那么有什么解决方案呢？</p>
<p><strong><font size="4px">解决方案：</font></strong></p>
<ol>
<li>在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</li>
<li>使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li>
<li>提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</li>
<li>为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</li>
</ol>
<p><br></p>
<h4 id="11-2、缓存击穿"><a href="#11-2、缓存击穿" class="headerlink" title="11.2、缓存击穿"></a>11.2、缓存击穿</h4><p>其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p>
<p><strong><font size="4px">分析：</font></strong></p>
<p>关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>
<p><strong><font size="4px">解决方案：</font></strong></p>
<ol>
<li>如果业务允许的话，对于热点的 key 可以设置永不过期。</li>
<li>使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。</li>
</ol>
<p><br></p>
<h4 id="11-3、缓存穿透"><a href="#11-3、缓存穿透" class="headerlink" title="11.3、缓存穿透"></a>11.3、缓存穿透</h4><p>我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</p>
<p><strong><font size="4px">分析：</font></strong></p>
<p>关键在于在Redis查不到key值，这和缓存击穿有根本的区别，区别在于<strong>缓存穿透的情况是传进来的key在Redis中是不存在的</strong>。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。</p>
<p><strong><font size="4px">解决方案：</font></strong></p>
<ol>
<li><strong>把无效的Key存进Redis中</strong>。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=”null”，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</li>
<li><strong>使用布隆过滤器</strong>。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/11/28/ouxz0f.png" alt="image"></p>
<p><br></p>
<h4 id="11-4、小结"><a href="#11-4、小结" class="headerlink" title="11.4、小结"></a>11.4、小结</h4><p>这三个问题在使用Redis的时候是肯定会遇到的，而且是非常致命性的问题，所以在日常开发中一定要注意，每次使用Redis时，都要对其保持严谨的态度。还有一个需要注意的是要做好熔断，一旦出现缓存雪崩，击穿，穿透这种情况，至少还有熔断机制保护数据库不会被打死。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/NoSQL/" rel="tag"># NoSQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/21/Linux/" rel="prev" title="Linux">
      <i class="fa fa-chevron-left"></i> Linux
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">一、什么是 Redis？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">1.1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E3%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">1.2、特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3%E3%80%81%E4%BC%98%E5%8A%BF"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">1.3、优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4%E3%80%81%E4%B8%8E%E5%85%B6%E5%AE%83-key-value-%E5%AD%98%E5%82%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">1.4、与其它 key-value 存储有什么不同？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Redis-%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">二、Redis 安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1%E3%80%81%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">2.1、安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2%E3%80%81redis-benchmark-%E6%B5%8B%E8%AF%95%E6%80%A7%E8%83%BD"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">2.2、redis-benchmark 测试性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81Redis-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">1.3.</span> <span class="nav-text">三、Redis 基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">3.1、数据库相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E3%80%81Redis-Key"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">3.2、Redis-Key</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">四、五大基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">4.1、字符串（String）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2%E3%80%81%E5%93%88%E5%B8%8C%EF%BC%88Hash%EF%BC%89"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">4.2、哈希（Hash）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3%E3%80%81%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">4.3、列表（List）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4%E3%80%81%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">4.4、集合（Set）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88sorted-set%EF%BC%89"><span class="nav-number">1.4.0.5.</span> <span class="nav-text">4.5、有序集合（sorted set）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">五、三种特殊数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1%E3%80%81Geo"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">5.1、Geo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E3%80%81HyperLogLog"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">5.2、HyperLogLog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3%E3%80%81Bitmaps"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">5.3、Bitmaps</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.6.</span> <span class="nav-text">六、事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1%E3%80%81%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">6.1、开启事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2%E3%80%81watch-%E7%9B%91%E5%90%AC"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">6.2、watch 监听</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81Jedis"><span class="nav-number">1.7.</span> <span class="nav-text">七、Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1%E3%80%81%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">7.1、配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2%E3%80%81Jedis-%E4%BD%BF%E7%94%A8"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">7.2、Jedis 使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81Redis-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.8.</span> <span class="nav-text">八、Redis 配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">九、持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">9.1、RDB 持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2%E3%80%81AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">9.2、AOF 持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3%E3%80%81%E8%AF%A6%E8%A7%A3-RDB-%E5%92%8C-AOF"><span class="nav-number">1.9.0.3.</span> <span class="nav-text">9.3、详解 RDB 和 AOF</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">1.10.</span> <span class="nav-text">十、发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%EF%BC%9F"><span class="nav-number">1.10.0.1.</span> <span class="nav-text">10.1、什么是发布订阅？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.10.0.2.</span> <span class="nav-text">10.2、发布订阅常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3%E3%80%81%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.0.3.</span> <span class="nav-text">10.3、原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.11.</span> <span class="nav-text">十一、主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-number">1.11.0.1.</span> <span class="nav-text">11.1、简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2%E3%80%81%E4%BD%9C%E7%94%A8"><span class="nav-number">1.11.0.2.</span> <span class="nav-text">11.2、作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.11.0.3.</span> <span class="nav-text">11.3、环境搭建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E6%88%98"><span class="nav-number">1.11.0.4.</span> <span class="nav-text">11.4、主从复制实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5%E3%80%81%E9%93%BE%E5%BC%8F%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.11.0.5.</span> <span class="nav-text">11.5、链式主从模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-6%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.0.6.</span> <span class="nav-text">11.6、主从复制运行原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-7%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88Sentinel%EF%BC%89%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-number">1.11.0.7.</span> <span class="nav-text">11.7、哨兵模式（Sentinel）【推荐】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-8%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98"><span class="nav-number">1.11.0.8.</span> <span class="nav-text">11.8、哨兵模式实战</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.</span> <span class="nav-text">十二、缓存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.12.0.1.</span> <span class="nav-text">11.1、缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">1.12.0.2.</span> <span class="nav-text">11.2、缓存击穿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">1.12.0.3.</span> <span class="nav-text">11.3、缓存穿透</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">1.12.0.4.</span> <span class="nav-text">11.4、小结</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="紫梦沁香"
      src="/uploads/images/head-icon.jpg">
  <p class="site-author-name" itemprop="name">紫梦沁香</p>
  <div class="site-description" itemprop="description">如果说我看得比别人更远些，那是因为我站在巨人的肩膀上</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1149911598@qq.com" title="E-Mail → mailto:1149911598@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">紫梦沁香</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'xxQvJd4TcJMGK327OtwyS41T-gzGzoHsz',
      appKey     : 'GJqvYfNtvELk0Vvow1MAQo5i',
      placeholder: "",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
