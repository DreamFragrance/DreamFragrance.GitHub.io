<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="连接池可以看到在 mybatis-config.xml 中有一个标签叫做 datasource（数据源），其中的 type 为 pooled，即池化，引入了数据库连接池的概念。 1、什么是连接池数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。 2、为什么要使用连接池数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库连接池">
<meta property="og:url" content="http://example.com/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/index.html">
<meta property="og:site_name" content="紫梦沁香">
<meta property="og:description" content="连接池可以看到在 mybatis-config.xml 中有一个标签叫做 datasource（数据源），其中的 type 为 pooled，即池化，引入了数据库连接池的概念。 1、什么是连接池数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。 2、为什么要使用连接池数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/IjEE0f.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/IjVCUU.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/Ijm324.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/IjmrxH.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/Ijn9y9.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/IjnKOA.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/11/21/Ijuph8.png">
<meta property="article:published_time" content="2021-11-21T08:22:33.000Z">
<meta property="article:modified_time" content="2021-11-24T03:27:32.556Z">
<meta property="article:author" content="紫梦沁香">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/11/21/IjEE0f.png">

<link rel="canonical" href="http://example.com/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库连接池 | 紫梦沁香</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc20780b9c032635241d71c52b76953";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script type="text/javascript" src="/js/game/modernizr.custom.js"></script>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">紫梦沁香</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-game">

    <a href="/game/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/images/head-icon.jpg">
      <meta itemprop="name" content="紫梦沁香">
      <meta itemprop="description" content="如果说我看得比别人更远些，那是因为我站在巨人的肩膀上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="紫梦沁香">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库连接池
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-21 16:22:33" itemprop="dateCreated datePublished" datetime="2021-11-21T16:22:33+08:00">2021-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-24 11:27:32" itemprop="dateModified" datetime="2021-11-24T11:27:32+08:00">2021-11-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase-System/" itemprop="url" rel="index"><span itemprop="name">DataBase System</span></a>
                </span>
            </span>

          
            <span id="/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" class="post-meta-item leancloud_visitors" data-flag-title="数据库连接池" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p>可以看到在 mybatis-config.xml 中有一个标签叫做 <code>datasource</code>（数据源），其中的 <code>type</code> 为 <code>pooled</code>，即池化，引入了数据库连接池的概念。</p>
<h2 id="1、什么是连接池"><a href="#1、什么是连接池" class="headerlink" title="1、什么是连接池"></a>1、什么是连接池</h2><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。</p>
<h2 id="2、为什么要使用连接池"><a href="#2、为什么要使用连接池" class="headerlink" title="2、为什么要使用连接池"></a>2、为什么要使用连接池</h2><p>数据库连接是一种关键的<strong>有限</strong>的<strong>昂贵</strong>的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，<strong>每次操作都打开一个物理连接，使用完都关闭连接</strong>，这样造成系统的<code>性能低下</code>。</p>
<p> 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 </p>
<h2 id="3、传统的连接机制与数据库连接池的运行机制区别"><a href="#3、传统的连接机制与数据库连接池的运行机制区别" class="headerlink" title="3、传统的连接机制与数据库连接池的运行机制区别"></a>3、传统的连接机制与数据库连接池的运行机制区别</h2><h4 id="3-1、不使用连接池执行一条-SQL-命令"><a href="#3-1、不使用连接池执行一条-SQL-命令" class="headerlink" title="3.1、不使用连接池执行一条 SQL 命令"></a>3.1、不使用连接池执行一条 SQL 命令</h4><p><img src="https://z3.ax1x.com/2021/11/21/IjEE0f.png" alt=""></p>
<ol>
<li>TCP建立连接的三次握手</li>
<li>MySQL认证的三次握手</li>
<li>真正的SQL执行</li>
<li>MySQL的关闭</li>
<li>TCP的四次挥手关闭</li>
</ol>
<p>可以看到，为了执行一条SQL，却多了非常多我们不关心的网络交互。</p>
<p>优点：</p>
<ul>
<li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>网络 IO 较多</li>
<li>数据库的负载较高</li>
<li>响应时间较长及 QPS 较低</li>
<li>应用频繁的创建连接和关闭连接，导致临时对象增多，GC 频繁</li>
<li>在关闭连接后，会出大量 TIME_WAIT 的 TCP 状态（在两个 MSL 之后关闭）</li>
</ul>
<h4 id="3-2、使用连接池执行一条-SQL-命令"><a href="#3-2、使用连接池执行一条-SQL-命令" class="headerlink" title="3.2、使用连接池执行一条 SQL 命令"></a>3.2、使用连接池执行一条 SQL 命令</h4><p><img src="https://z3.ax1x.com/2021/11/21/IjVCUU.png" alt=""></p>
<p>第一次访问的时候，需要建立连接。 但是之后的访问，均会<strong>复用</strong>之前创建的连接，直接执行SQL语句（图中黄色的部分）。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>较少了网络开销</p>
</li>
<li><p>系统的性能会有一个实质的提升</p>
</li>
<li><p>没了麻烦的TIME_WAIT状态</p>
</li>
</ul>
<h2 id="4、数据库连接池的工作原理"><a href="#4、数据库连接池的工作原理" class="headerlink" title="4、数据库连接池的工作原理"></a>4、数据库连接池的工作原理</h2><p>连接池的工作原理主要由三部分组成，分别为</p>
<ul>
<li><p>连接池的建立</p>
</li>
<li><p>连接池中连接的使用管理</p>
</li>
<li><p>连接池的关闭</p>
</li>
</ul>
<p> <strong>连接池的建立</strong>：</p>
<p>​        一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。</p>
<p><strong>连接池的管理</strong>：</p>
<p>​        连接池管理策略是<strong>连接池机制的核心</strong>，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：</p>
<p>​        当客户<strong>请求</strong>数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。</p>
<p>​        当客户<strong>释放</strong>数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。</p>
<p>​        该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。</p>
<p><strong>连接池的关闭</strong>：</p>
<p>当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
<h2 id="5、连接池需要注意的点"><a href="#5、连接池需要注意的点" class="headerlink" title="5、连接池需要注意的点"></a>5、连接池需要注意的点</h2><h4 id="5-1、并发问题"><a href="#5-1、并发问题" class="headerlink" title="5.1、并发问题"></a>5.1、<strong><font size="5px">并发问题</font></strong></h4><p>　　为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像java,c#等等，使用synchronized(java)、lock(C#)关键字即可确保线程是同步的。</p>
<h4 id="5-2、事务处理"><a href="#5-2、事务处理" class="headerlink" title="5.2、事务处理"></a>5.2、<strong><font size="5px">事务处理</font></strong></h4><p>​        我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组SQL语句要么全做，要么全不做。<br>　　我们知道当2个线程共用一个连接Connection对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使Connection类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。 </p>
<h4 id="5-3连接池的分配与释放"><a href="#5-3连接池的分配与释放" class="headerlink" title="5.3连接池的分配与释放"></a>5.3<strong><font size="5px">连接池的分配与释放</font></strong></h4><p>​        连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。<br>　　对于连接的管理可使用一个List。即把已经创建的连接都放入List中去统一管理。每当用户请求一个连接时，系统检查这个List中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户，List中连接是否可以被分配由一个线程来专门管理。</p>
<h4 id="5-4、连接池的配置与维护"><a href="#5-4、连接池的配置与维护" class="headerlink" title="5.4、连接池的配置与维护"></a>5.4、<strong><font size="5px">连接池的配置与维护</font></strong></h4><p>​        连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。<br>　　如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接，以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>
<h2 id="6、主流数据源对比"><a href="#6、主流数据源对比" class="headerlink" title="6、主流数据源对比"></a>6、主流数据源对比</h2><p>区分一个数据库连接池是属于第一代产品还是代二代产品有一个最重要的特征就是看它在架构和设计时采用的线程模型，因为这直接影响的是<strong>并发环境下存取数据库连接的性能</strong>。</p>
<p>一般来讲采用单线程同步的架构设计都属于第一代连接池，二采用<strong>多线程异步架构</strong>的则属于第二代。比较有代表性的就是Apache Commons DBCP，在1.x版本中，一直延续着单线程设计模式，到2.x才采用多线程模型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据库连接池</strong></th>
<th><strong>最新版本</strong></th>
<th><strong>发布时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>C3P0</td>
<td>c3p0-0.9.5.2</td>
<td>on 9 Dec 2015</td>
</tr>
<tr>
<td>DBCP</td>
<td>2.2.0</td>
<td>27 December 2017</td>
</tr>
<tr>
<td>Druid</td>
<td>0.11.0</td>
<td>Dec 4 2017</td>
</tr>
<tr>
<td>HikariCP</td>
<td>2.7.6</td>
<td>2018-01-14</td>
</tr>
</tbody>
</table>
</div>
<p>从表中可以看出，C3P0已经很久没有更新了。DBCP更新速度很慢，基本处于不活跃状态，而Druid和HikariCP处于活跃状态的更新中，这就是我们说的二代产品了。</p>
<p>二代产品对一代产品的超越是颠覆性的，除了一些“历史原因”，你很难再找到第二条理由说服自己不选择二代产品，但任何成功都不是偶然的，二代产品的成功很大程度上得益于前代产品们打下的基础，站在巨人的肩膀上，新一代的连接池的设计师们将这一项“工具化”的产品，推向了极致。其中，最具代表性的两款产品是：</p>
<ul>
<li>HikariCP</li>
<li>Druid</li>
</ul>
<h4 id="6-1、彻底死掉的-C3P0"><a href="#6-1、彻底死掉的-C3P0" class="headerlink" title="6.1、彻底死掉的 C3P0"></a>6.1、<strong><font size="5px">彻底死掉的 C3P0</font></strong></h4><p>在很长一段时间内，C3P0 一直是Java领域内数据库连接池的代名词，当年盛极一时的Hibernate 都将其作为内置的数据库连接池，可以业内对它的稳定性还是认可的。C3P0 功能简单易用，稳定性好这是它的优点，<strong>但是性能上的缺点却让它彻底被打入冷宫</strong>。C3P0 的性能很差，差到即便是同时代的产品相比它也是垫底的，更不用和 Druid、HikariCP 等相比了。正常来讲，有问题很正常，改就是了，<strong>但c3p0最致命的问题就是架构设计过于复杂，让重构变成了一项不可能完成的任务</strong>。随着国内互联网大潮的涌起，性能有硬伤的c3p0彻底的退出了历史舞台，图表如下（左侧为响应时间，单位毫秒）。</p>
<p><img src="https://z3.ax1x.com/2021/11/21/Ijm324.png" alt=""></p>
<h4 id="6-2、咸鱼翻身的-DBCP"><a href="#6-2、咸鱼翻身的-DBCP" class="headerlink" title="6.2、咸鱼翻身的 DBCP"></a>6.2、<strong><font size="5px">咸鱼翻身的 DBCP</font></strong></h4><p>DBCP（DataBase Connection Pool）属于 Apache 顶级项目 Commons 中的核心子项目（最早在Jakarta Commons里就有）,在 Apache 的生态圈中的影响里十分广泛，比如最为大家所熟知的 Tomcat 就在内部集成了 DBCP，实现 JPA 规范的 OpenJPA ，也是默认集成 DBCP 的。但 <strong>DBCP 并不是独立实现连接池功能的，它内部依赖于 Commons 中的另一个子项目 Pool，连接池最核心的“池”，就是由 Pool 组件提供的</strong>，因此，DBCP 的性能实际上就是 Pool 的性能，DBCP 和 Pool 的依赖关系如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Apache Commons DBCP</strong></th>
<th><strong>Apache Commons Pool</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>v1.2.2</td>
<td>v1.3</td>
</tr>
<tr>
<td>v1.3</td>
<td>v1.5.4</td>
</tr>
<tr>
<td>v1.4</td>
<td>v1.5.4</td>
</tr>
<tr>
<td>v2.0.x</td>
<td>v2.2</td>
</tr>
<tr>
<td>v2.1.x</td>
<td>v2.4.2</td>
</tr>
<tr>
<td>v2.2.x</td>
<td>v2.5.0</td>
</tr>
</tbody>
</table>
</div>
<p>可以看到，因为核心功能依赖于 Pool，所以 DBCP 本身只能做小版本的更新，真正大版本的更迭则完全依托于 pool。有很长一段时间，pool 都还是停留在1.x版本，这直接导致 DBCP 也更新乏力。很多依赖 DBCP 的应用在遇到性能瓶颈之后，别无选择，只能将其替换掉，DBCP忠实的拥趸 tomcat 就在其 tomcat 7.0 版本中，自己重新设计开发出了一套连接池（Tomcat JDBC Pool）。好在，在2013年事情终于迎来转机，13年9月 Commons-Pool 2.0 版本发布，14年2月份，DBCP也终于迎来了自己的2.0版本，基于新的线程模型全新设计的“池”让 DBCP 重焕青春，虽然和新一代的连接池相比仍有一定差距，但差距并不大，DBCP2.x 版本已经稳稳达到了和新一代产品同级别的性能指标（见下图）。</p>
<p><img src="https://z3.ax1x.com/2021/11/21/IjmrxH.png" alt=""></p>
<p>DBCP 终于靠 Pool 咸鱼翻身，打了一个漂亮的翻身仗，但长时间的等待已经完全消磨了用户的耐心，与新一代的产品项目相比，DBCP 没有任何优势，试问，谁会在有选择的前提下，去选择那个并不优秀的呢？也许，现在还选择 DBCP2 的唯一理由，就是情怀吧。</p>
<h4 id="6-3、性能无敌的-HikariCP"><a href="#6-3、性能无敌的-HikariCP" class="headerlink" title="6.3、性能无敌的 HikariCP"></a>6.3、<strong><font size="5px">性能无敌的 HikariCP</font></strong></h4><p>HikariCP 号称“性能杀手”（It’s Faster），它的表现究竟如何呢，先来看下官网提供的数据：</p>
<p><img src="https://z3.ax1x.com/2021/11/21/Ijn9y9.png" alt=""></p>
<p>不光性能强劲，稳定性也不差：</p>
<p><img src="https://z3.ax1x.com/2021/11/21/IjnKOA.png" alt=""></p>
<p>那它是怎么做到如此强劲的呢？官网给出的说明如下：</p>
<ul>
<li>字节码精简：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；</li>
<li>优化代理和拦截器：减少代码，例如HikariCP的Statement proxy只有100行代码；</li>
<li>自定义数组类型（FastStatementList）代替ArrayList：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；</li>
<li>自定义集合类型（ConcurrentBag）：提高并发读写的效率；</li>
<li>其他缺陷的优化，比如对于耗时超过一个CPU时间片的方法调用的研究（但没说具体怎么优化）。</li>
</ul>
<p>可以看到，上述这几点优化，和现在能找到的资料来看，HakariCP 在性能上的优势应该是得到共识的，再加上它自身小巧的身形，在当前的“云时代、微服务”的背景下，HakariCP 一定会得到更多人的青睐。</p>
<h4 id="6-4、功能全面的-Druid"><a href="#6-4、功能全面的-Druid" class="headerlink" title="6.4、功能全面的 Druid"></a>6.4、<strong><font size="5px">功能全面的 Druid</font></strong></h4><p>近几年，阿里在开源项目上动作频频，除了有像fastJson、dubbo这类项目，更有像AliSQL这类的大型软件，今天说的Druid，就是阿里众多优秀开源项目中的一个。它除了提供性能卓越的连接池功能外，还集成了SQL监控，黑名单拦截等功能，用它自己的话说，Druid是“为监控而生”。借助于阿里这个平台的号召力，产品一经发布就赢得了大批用户的拥趸，从用户使用的反馈来看，Druid也确实没让用户失望。</p>
<p>相较于其他产品，Druid另一个比较大的优势，就是中文文档比较全面（毕竟是国人的项目么），在github的wiki页面，列举了日常使用中可能遇到的问题，对一个新用户来讲，上面提供的内容已经足够指导它完成产品的配置和使用了。</p>
<p>下图为Druid自己提供的性能测试数据：</p>
<p><img src="https://z3.ax1x.com/2021/11/21/Ijuph8.png" alt=""></p>
<p><strong>Druid 相对于其他数据库连接池的优点</strong></p>
<ul>
<li><p>强大的监控特性，通过Druid提供的监控功能，可以清楚知道连接池和SQL的工作情况。</p>
<ul>
<li>监控SQL的执行时间、ResultSet持有时间、返回行数、更新行数、错误次数、错误堆栈信息；</li>
<li>SQL执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个SQL执行了1000次，其中0~1毫秒区间50次，1~10毫秒800次，10~100毫秒100次，100~1000毫秒30次，1~10秒15次，10秒以上5次。通过耗时区间分布，能够非常清楚知道SQL的执行耗时情况；</li>
<li>监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache命中率等。</li>
</ul>
</li>
<li><p>方便扩展。Druid提供了Filter-Chain模式的扩展API，可以自己编写Filter拦截JDBC中的任何方法，可以在上面做任何事情，比如说性能监控、SQL审计、用户名密码加密、日志等等。</p>
</li>
<li>Druid集合了开源和商业数据库连接池的优秀特性，并结合阿里巴巴大规模苛刻生产环境的使用经验进行优化。</li>
</ul>
<h2 id="7、小结"><a href="#7、小结" class="headerlink" title="7、小结"></a>7、小结</h2><p>时至今日，虽然每个应用（需要 RDBMS 的）都离不开连接池，但在实际使用的时候，连接池已经可以做到“隐形”了。也就是说在通常情况下，连接池完成项目初始化配置之后，就再不需要再做任何改动了。不论你是选择 Druid 或是 HikariCP，甚至是 DBCP，它们都足够稳定且高效！之前讨论了很多关于连接池的性能的问题，但这些性能上的差异，是相较于其他连接池而言的，对整个系统应用来说，第二代连接池在使用过程中体会到的差别是微乎其微的，基本上不存在因为连接池的自身的配饰和使用导致系统性能下降的情况，除非是在单点应用的数据库负载足够高的时候（压力测试的时候），但即便是如此，通用的优化的方式也是单点改集群，而不是在单点的连接池上死扣。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/15/MySQL/" rel="prev" title="MySQL">
      <i class="fa fa-chevron-left"></i> MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/21/Linux/" rel="next" title="Linux">
      Linux <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">1、什么是连接池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">2、为什么要使用连接池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8C%BA%E5%88%AB"><span class="nav-text">3、传统的连接机制与数据库连接池的运行机制区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-SQL-%E5%91%BD%E4%BB%A4"><span class="nav-text">3.1、不使用连接池执行一条 SQL 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-SQL-%E5%91%BD%E4%BB%A4"><span class="nav-text">3.2、使用连接池执行一条 SQL 命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">4、数据库连接池的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="nav-text">5、连接池需要注意的点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1%E3%80%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">5.1、并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-text">5.2、事务处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-text">5.3连接池的分配与释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BB%B4%E6%8A%A4"><span class="nav-text">5.4、连接池的配置与维护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AF%B9%E6%AF%94"><span class="nav-text">6、主流数据源对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1%E3%80%81%E5%BD%BB%E5%BA%95%E6%AD%BB%E6%8E%89%E7%9A%84-C3P0"><span class="nav-text">6.1、彻底死掉的 C3P0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2%E3%80%81%E5%92%B8%E9%B1%BC%E7%BF%BB%E8%BA%AB%E7%9A%84-DBCP"><span class="nav-text">6.2、咸鱼翻身的 DBCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3%E3%80%81%E6%80%A7%E8%83%BD%E6%97%A0%E6%95%8C%E7%9A%84-HikariCP"><span class="nav-text">6.3、性能无敌的 HikariCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4%E3%80%81%E5%8A%9F%E8%83%BD%E5%85%A8%E9%9D%A2%E7%9A%84-Druid"><span class="nav-text">6.4、功能全面的 Druid</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-text">7、小结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="紫梦沁香"
      src="/uploads/images/head-icon.jpg">
  <p class="site-author-name" itemprop="name">紫梦沁香</p>
  <div class="site-description" itemprop="description">如果说我看得比别人更远些，那是因为我站在巨人的肩膀上</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1149911598@qq.com" title="E-Mail → mailto:1149911598@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">紫梦沁香</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'xxQvJd4TcJMGK327OtwyS41T-gzGzoHsz',
      appKey     : 'GJqvYfNtvELk0Vvow1MAQo5i',
      placeholder: "",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
